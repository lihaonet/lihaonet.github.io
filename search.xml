<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>省考资料</title>
    <url>//b595ee6b.html</url>
    <content><![CDATA[<p>移动端请使用 桌面版网站 打开；PC端可正常显示；加载慢，给我一首歌的时间！<br>
后期文件将移至<a href="http://bugtrap.ysepan.com"> 永硕E盘 </a><br>
<button><a href="/pdfjs/web/viewer.html?file=/PDF/yanyu1.pdf">言语1全屏查看</a></button></p>
<iframe src='/pdfjs/web/viewer.html?file=/PDF/yanyu1.pdf' style='width:100%;height:550px'></iframe>
<button><a href="/pdfjs/web/viewer.html?file=/PDF/panduan2.pdf">判断2全屏查看</a></button>
<p><button><a href="/pdfjs/web/viewer.html?file=/PDF/ziliao3.pdf">资料3全屏查看</a></button></p>
<p><button><a href="/pdfjs/web/viewer.html?file=/PDF/shenlun4.pdf">申论4全屏查看</a></button></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>//4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>文章设置</title>
    <url>//3d89410.html</url>
    <content><![CDATA[<p>title: 文章标题<br>
date: 时间 2024-1-1 10:10:45<br>
tags: 标签 hexo<br>
sticky: 置顶 1</p>
<p><a href="https://kissingfire123.github.io/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/#5%E5%BE%AE%E7%A7%AF%E5%88%86%E8%BF%90%E7%AE%97%E7%AC%A6">https://kissingfire123.github.io/2022/02/18_数学公式katex常用语法总结/#5微积分运算符</a></p>
<p><a href="https://katex.org/docs/supported">https://katex.org/docs/supported</a></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">∥</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">∥</mo></mrow><annotation encoding="application/x-tex">\begin{Vmatrix}
   a &amp; b \\
   c &amp; d
\end{Vmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.556em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.556em' height='2.400em' viewBox='0 0 556 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z
M367 15 v585 v1200 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.556em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.556em' height='2.400em' viewBox='0 0 556 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z
M367 15 v585 v1200 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><img src="https://lin64850.github.io/img/beiji.jpg" alt="背景"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">light</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created创建日期 or updated更新日期 or both都展示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">relative</span> <span class="comment"># date/relative 绝对/相对日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示标签</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 是否显示描述性文字</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created创建日期 or updated更新日期 or both都展示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">relative</span> <span class="comment"># date/relative 绝对/相对日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示标签</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 是否显示描述性文字</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>记事簿</title>
    <url>//61933d8.html</url>
    <content><![CDATA[<figure class="highlight v"><figcaption><span>村代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="number">140882001001</span></span><br><span class="line"><span class="number">140882001002</span></span><br><span class="line"><span class="number">140882001003</span></span><br><span class="line"><span class="number">140882001004</span></span><br><span class="line"><span class="number">140882001005</span></span><br><span class="line"><span class="number">140882001006</span></span><br><span class="line"><span class="number">140882001007</span></span><br><span class="line"><span class="number">140882001008</span></span><br><span class="line"><span class="number">140882001010</span></span><br><span class="line"><span class="number">140882001200</span></span><br><span class="line"><span class="number">140882001201</span></span><br><span class="line"><span class="number">140882001202</span></span><br><span class="line"><span class="number">140882001204</span></span><br><span class="line"><span class="number">140882001205</span></span><br><span class="line"><span class="number">140882001206</span></span><br><span class="line"><span class="number">140882001207</span></span><br><span class="line"><span class="number">140882001208</span></span><br><span class="line"><span class="number">140882001210</span></span><br><span class="line"><span class="number">140882001211</span></span><br><span class="line"><span class="number">140882001214</span></span><br><span class="line"><span class="number">140882001219</span></span><br><span class="line"><span class="number">140882002004</span></span><br><span class="line"><span class="number">140882002016</span></span><br><span class="line"><span class="number">140882002017</span></span><br><span class="line"><span class="number">140882002020</span></span><br><span class="line"><span class="number">140882002200</span></span><br><span class="line"><span class="number">140882002204</span></span><br><span class="line"><span class="number">140882002205</span></span><br><span class="line"><span class="number">140882002207</span></span><br><span class="line"><span class="number">140882002212</span></span><br><span class="line"><span class="number">140882002213</span></span><br><span class="line"><span class="number">140882003200</span></span><br><span class="line"><span class="number">140882003203</span></span><br><span class="line"><span class="number">140882003204</span></span><br><span class="line"><span class="number">140882003205</span></span><br><span class="line"><span class="number">140882003207</span></span><br><span class="line"><span class="number">140882004200</span></span><br><span class="line"><span class="number">140882004205</span></span><br><span class="line"><span class="number">140882004208</span></span><br><span class="line"><span class="number">140882004209</span></span><br><span class="line"><span class="number">140882100201</span></span><br><span class="line"><span class="number">140882100202</span></span><br><span class="line"><span class="number">140882100212</span></span><br><span class="line"><span class="number">140882100214</span></span><br><span class="line"><span class="number">140882100217</span></span><br><span class="line"><span class="number">140882100222</span></span><br><span class="line"><span class="number">140882101200</span></span><br><span class="line"><span class="number">140882101205</span></span><br><span class="line"><span class="number">140882101206</span></span><br><span class="line"><span class="number">140882101207</span></span><br><span class="line"><span class="number">140882101209</span></span><br><span class="line"><span class="number">140882101211</span></span><br><span class="line"><span class="number">140882101221</span></span><br><span class="line"><span class="number">140882102200</span></span><br><span class="line"><span class="number">140882200200</span></span><br><span class="line"><span class="number">140882200206</span></span><br><span class="line"><span class="number">140882200211</span></span><br><span class="line"><span class="number">140882200214</span></span><br><span class="line"><span class="number">140882200215</span></span><br><span class="line"><span class="number">140882203200</span></span><br><span class="line"><span class="number">140882400498</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ml"><figcaption><span>名录划分</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	农业</span><br><span class="line"><span class="number">5</span>	农、林、牧、渔业专业及辅助性活动</span><br><span class="line"><span class="number">6</span>	工业</span><br><span class="line"><span class="number">47</span>	建筑业</span><br><span class="line"><span class="number">51</span>	批发零售业</span><br><span class="line"><span class="number">53</span>	交通运输、仓储和邮政业</span><br><span class="line"><span class="number">61</span>	住宿和餐饮业</span><br><span class="line"><span class="number">63</span>	服务业</span><br><span class="line"><span class="number">66</span>	金融业</span><br><span class="line"><span class="number">70</span>	房地产业</span><br><span class="line"></span><br><span class="line">=<span class="type">IFS</span>(<span class="type">C2</span>&gt;<span class="string">&quot;70&quot;</span>,<span class="string">&quot;服务业&quot;</span>,<span class="type">C2</span>=<span class="string">&quot;70&quot;</span>,<span class="string">&quot;房地产业&quot;</span>,<span class="type">C2</span>&gt;=<span class="string">&quot;66&quot;</span>,<span class="string">&quot;金融业&quot;</span>,<span class="type">C2</span>&gt;=<span class="string">&quot;63&quot;</span>,<span class="string">&quot;服务业&quot;</span>,<span class="type">C2</span>&gt;=<span class="string">&quot;61&quot;</span>,<span class="string">&quot;住宿和餐饮业&quot;</span>,<span class="type">C2</span>&gt;=<span class="string">&quot;53&quot;</span>,<span class="string">&quot;交通运输、仓储和邮政业&quot;</span>,<span class="type">C2</span>&gt;=<span class="string">&quot;51&quot;</span>,<span class="string">&quot;批发零售业&quot;</span>,<span class="type">C2</span>&gt;=<span class="string">&quot;47&quot;</span>,<span class="string">&quot;建筑业&quot;</span>,<span class="type">C2</span>&gt;=<span class="string">&quot;06&quot;</span>,<span class="string">&quot;工业&quot;</span>,<span class="type">C2</span>=<span class="string">&quot;05&quot;</span>,<span class="string">&quot;农、林、牧、渔业专业及辅助性活动&quot;</span>,<span class="type">C2</span>&gt;=<span class="string">&quot;01&quot;</span>,<span class="string">&quot;农业&quot;</span>)  // 类型判断</span><br><span class="line"></span><br><span class="line">=<span class="type">COUNTIF</span>(<span class="type">E</span>:<span class="type">E</span>,<span class="type">E1</span>) // 计数</span><br></pre></td></tr></table></figure>
<figure class="highlight excel"><figcaption><span>BAT/CMD</span></figcaption><table><tr><td class="code"><pre><span class="line">Excel </span><br><span class="line">	ctrl shift 上箭头；输入 Ctrl+enter填充全部；&amp;拼接</span><br><span class="line">	<span class="built_in">left</span>截取函数    <span class="built_in">countif</span>计数判断  <span class="built_in">MID</span>截取中间数值  <span class="built_in">TEXT</span>(x,<span class="string">&quot;yyyymmdd&quot;</span>)统一格式 <span class="built_in">VLOOKUP</span>比对匹配返回</span><br><span class="line">	<span class="built_in">SUBSTITUTE</span>()替换字符串</span><br><span class="line">    大表中<span class="built_in">vlookup</span>（大表关键字，小表数据【关键字在首列】，返回的匹配列数，<span class="built_in">FALSE</span>【精确查找】）</span><br><span class="line">    不复制隐藏行 选中数据区域—按【Alt+;】 再CV</span><br><span class="line">	</span><br><span class="line">BAT/CMD</span><br><span class="line">	MD创建目录 <span class="string">&quot;C:\Users\统计局\Desktop\kv-project\名&quot;</span></span><br><span class="line">	pause暂停</span><br><span class="line">	显示目录 DIR   重定向  覆盖&gt; 追加&gt;&gt;    通配符 * ? 如*.txt</span><br><span class="line">	DIR /b当前全部文件名 /s绝对路径  &gt;&gt; name.txt  替换</span><br><span class="line">	REN重命名 旧.txt 新.txt</span><br><span class="line">	COPY复制  移动MOVE /-y确定覆盖  删除DEL /s递归  /q直接删不提示</span><br><span class="line">	echo off执行时不输出命令  @echo %<span class="built_in">time</span>% %<span class="built_in">date</span>% &gt;&gt; 记录.txt</span><br><span class="line">	Win10系统开机启动文件夹路径<span class="number">1</span>. C：\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp <span class="number">2</span>.运行 输入 she<span class="symbol">ll:Co</span>mmon Startup  bat文件放入即可</span><br><span class="line">	计划任务</span><br><span class="line"></span><br><span class="line">myzx <span class="number">03595031128</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> nul&gt;<span class="number">1</span>.txt</span><br><span class="line"><span class="number">140882001</span> <span class="number">140882002</span> <span class="number">140882003</span> <span class="number">140882004</span> <span class="number">140882100</span> <span class="number">140882101</span> <span class="number">140882102</span> <span class="number">140882200</span> <span class="number">140882203</span> <span class="number">140882400</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>selenium</span></figcaption><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;[id$=填表人移动电话]&quot;</span>).<span class="title function_">val</span>($(<span class="string">&quot;[id$=移动电话]&quot;</span>).<span class="title function_">val</span>())</span><br><span class="line">$(<span class="string">&quot;[id$=实际负责人]&quot;</span>).<span class="title function_">val</span>($(<span class="string">&quot;[id$=法定代表人]&quot;</span>).<span class="title function_">val</span>())</span><br><span class="line">$(<span class="string">&quot;[id$=统计负责人]&quot;</span>).<span class="title function_">val</span>($(<span class="string">&quot;[id$=法定代表人]&quot;</span>).<span class="title function_">val</span>())</span><br><span class="line">$(<span class="string">&quot;[id$=填表人]&quot;</span>).<span class="title function_">val</span>($(<span class="string">&quot;[id$=法定代表人]&quot;</span>).<span class="title function_">val</span>())</span><br><span class="line">$(<span class="string">&quot;[id$=填表日期_edt年]&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;2023&quot;</span>)</span><br><span class="line">$(<span class="string">&quot;[id$=填表日期_edt月]&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;10&quot;</span>)</span><br><span class="line">$(<span class="string">&quot;[id$=填表日期_edt日]&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;16&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.<span class="property">webdriver</span>.<span class="property">edge</span>.<span class="property">options</span> <span class="keyword">import</span> <span class="title class_">Options</span></span><br><span class="line"><span class="keyword">from</span> selenium.<span class="property">webdriver</span>.<span class="property">common</span>.<span class="property">by</span> <span class="keyword">import</span> <span class="title class_">By</span></span><br><span class="line"><span class="keyword">from</span> selenium.<span class="property">webdriver</span>.<span class="property">support</span>.<span class="property">ui</span> <span class="keyword">import</span> <span class="title class_">WebDriverWait</span></span><br><span class="line"><span class="keyword">from</span> selenium.<span class="property">webdriver</span>.<span class="property">support</span> <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> <span class="variable constant_">EC</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"># 设置<span class="title class_">Edge</span>驱动程序路径</span><br><span class="line">options=<span class="title class_">Options</span>()</span><br><span class="line">options.<span class="property">binary_location</span> = <span class="string">&#x27;C:/Users/msedgedriver.exe&#x27;</span></span><br><span class="line">driver = webdriver.<span class="title class_">Edge</span>(options=options)</span><br><span class="line"># 打开网站</span><br><span class="line">url = <span class="string">&quot;&quot;</span></span><br><span class="line">driver.<span class="title function_">get</span>(url)</span><br><span class="line"># 等待数据加载完成，这里使用一个简单的等待条件，根据网站实际情况进行调整</span><br><span class="line">wait = <span class="title class_">WebDriverWait</span>(driver, <span class="number">10</span>)</span><br><span class="line">wait.<span class="title function_">until</span>(<span class="variable constant_">EC</span>.<span class="title function_">presence_of_element_located</span>((<span class="title class_">By</span>.<span class="property">CSS_SELECTOR</span>, <span class="string">&#x27;&#x27;</span>)))</span><br><span class="line"># 获取数据</span><br><span class="line">data = []</span><br><span class="line"># 假设数据在表格中，使用合适的选择器来定位表格</span><br><span class="line">table = driver.<span class="title function_">find_element</span>(<span class="title class_">By</span>.<span class="property">CSS_SELECTOR</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">rows = table.<span class="title function_">find_elements</span>(<span class="title class_">By</span>.<span class="property">TAG_NAME</span>, <span class="string">&#x27;tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="attr">rows</span>:</span><br><span class="line">    row_data = [cell.<span class="property">text</span> <span class="keyword">for</span> cell <span class="keyword">in</span> row.<span class="title function_">find_elements</span>(<span class="title class_">By</span>.<span class="property">TAG_NAME</span>, <span class="string">&#x27;td&#x27;</span>)]</span><br><span class="line">    data.<span class="title function_">append</span>(row_data)</span><br><span class="line">    <span class="title function_">print</span>(data)</span><br><span class="line"># 关闭浏览器</span><br><span class="line">driver.<span class="title function_">quit</span>()</span><br><span class="line"></span><br><span class="line"># 数据处理（如果需要进一步处理，请在此进行）</span><br><span class="line"># 导出到<span class="title class_">Excel</span></span><br><span class="line"># output_file = <span class="string">&quot;table_data.xlsx&quot;</span></span><br><span class="line"># df = pd.<span class="title class_">DataFrame</span>(data[<span class="number">1</span>:], columns=data[<span class="number">0</span>])  # 使用pandas创建数据框</span><br><span class="line"># df.<span class="title function_">to_excel</span>(output_file, index=<span class="title class_">False</span>)  # 将数据框保存为<span class="title class_">Excel</span>文件/<span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"># 禁用requests出现的取消ssl验证的警告，直接引用如下</span><br><span class="line"><span class="keyword">from</span> urllib3.<span class="property">exceptions</span> <span class="keyword">import</span> <span class="title class_">InsecureRequestWarning</span></span><br><span class="line">requests.<span class="property">packages</span>.<span class="property">urllib3</span>.<span class="title function_">disable_warnings</span>(<span class="title class_">InsecureRequestWarning</span>)</span><br><span class="line"># 步骤<span class="number">1</span>: 伪装浏览器</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.61&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">cookies = &#123;</span><br><span class="line">    <span class="string">&#x27;pn&#x27;</span>: <span class="string">&#x27;default/project&#x27;</span>,</span><br><span class="line">    # 添加更多的<span class="title class_">Cookies</span>，根据实际情况</span><br><span class="line">&#125;</span><br><span class="line"># 步骤<span class="number">2</span>: 获取网站数据</span><br><span class="line">url = <span class="string">&quot;&quot;</span></span><br><span class="line">response = requests.<span class="title function_">post</span>(url, headers=headers, cookies=cookies, data=payload, verify=<span class="title class_">False</span>)</span><br><span class="line"><span class="title function_">print</span>(response.<span class="property">text</span>)</span><br><span class="line"># 检查请求是否成功</span><br><span class="line"><span class="keyword">if</span> response.<span class="property">status_code</span> == <span class="number">200</span>:</span><br><span class="line">    # 解析<span class="title class_">JSON</span>数据</span><br><span class="line">    data = response.<span class="title function_">json</span>()</span><br><span class="line">    # 在这里您可以处理数据，例如打印它</span><br><span class="line">    <span class="title function_">print</span>(data)</span><br><span class="line"><span class="attr">else</span>:</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&quot;请求失败，状态码:&quot;</span>, response.<span class="property">status_code</span>)</span><br><span class="line"></span><br><span class="line">msedge.<span class="property">exe</span> --remote-debugging-port=<span class="number">9222</span> --user-data-dir=<span class="string">&quot;C:\Users\Desktop\seleniumlog&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>好软分享</title>
    <url>//d3d73bbd.html</url>
    <content><![CDATA[<div>
    <div>
        <button>
            <a href="https://github.com/hiroi-sora/Umi-OCR">Umi-OCR</a>
        </button>
        <b> : Umi-OCR 是一款在GitHub开源免费的文字识别工具，它能够将图像中的文字提取出来，并将其转化为可编辑的文本。 这项技术基于深度学习和计算机视觉算法，具备出色的准确性和高效的处理能力。</b>
    </div>
    <div>
        <button>
            <a href="https://www.pdfgear.com/">PDFgear</a>
        </button>
        <b>  : PDFgear集聊天、编辑、压缩、阅读、转换、注释、签名、整理、打印、表单、OCR识别于一体，几乎涵盖了所有PDF相关的操作。</b>
    </div>
    <div>buyixiao.github.io</div>
    <div></div>
<pre><code>#在线工具 #抠图 #PS #换背景
图片：
无需登录：
    BgSub https://bgsub.cn/
    在线抠图 换底 https://www.remove.bg/zh
    起兮深探-AI智能在线抠图 http://matting.deeplor.com/#/
    
需登录：
    FocoClipping https://www.fococlipping.com/
    稿定设计 https://www.gaoding.com/koutu
    创客贴 https://www.chuangkit.com/koutu
    美图秀秀 https://pc.meitu.com/design/koutu/
    佐糖 https://www.apowersoft.cn/remove-background-online

有点卡：
    在线抠图 https://www.6k6k.cn/
    照片编辑器 https://photokit.com/
    Clipping Magic：删除线上图像背景 https://zh.clippingmagic.com/

视频Remove Video Background：
    Runway https://runwayml.com/
    Unscreen https://www.unscreen.com/

去水印：
    https://quququ.cn/

待分类：
    Background remover: https://www.photoroom.com/background-remover/
    在线抠图和智能背景去除 https://www.cutout.pro/zh-CN
    在线背景去除器PicWish https://picwish.com/
    Removebackground https://www.slazzer.com/
</code></pre>
</div>
]]></content>
  </entry>
  <entry>
    <title>每日一言</title>
    <url>//bca05d86.html</url>
    <content><![CDATA[<p>一个人的价值, 在于他贡献了什么, 而不在于他获得了什么!	@爱因斯坦<br>
你若喜爱你自己的价值, 你就得给世界创造价值!	@歌德<br>
未经反思自省的人生不值得去过 The unexamined life is not worth living. @苏格拉底 (哲学之父)<br>
大多数人在20到30岁就已经过完自己的一生; 一过了这个年龄段, 他们就变成自己的影子, 以后的生命只是在不断重复自己…	@&lt;约翰.克里斯朵夫&gt;罗曼.罗兰 (作家 诺贝尔奖得主)<br>
活着, 如同生命最后一天般活着; 学习, 如同永远活着般学习!	@圣雄甘地 (印度国父)<br>
人所面对的绝境, 在很多情况下都不是生存的绝境, 而是[精神]的绝境!<br>
世上只有一种英雄主义 – 就是在认清生活的真相之后依然热爱生活 @罗曼.罗兰 (作家 诺贝尔奖得主)<br>
人的一切痛苦都是源于对自己无能的愤怒 @王小波 (作家)<br>
Stay hungry. Stay foolish. @乔布斯引自&lt;全球概览&gt;	<br>
人生中最大的两个财富是: 你的[才华]和你的[时间];	才华越来越多而时间越来越少;我们的一生就是用时间来换取才华;<br>
拥有追随自己内心与直觉的勇气 – 你的内心与直觉多少已经知道你真正想要成为什么样的人	Have the courage to follow your heart and intuition. They somehow already know what you truly want to become. @乔布斯	<br>
善良比聪明重要 – 聪明是一种天赋, 而善良是一种选择	Cleverness is a gift, kindness is a choice.	@贝佐斯 (亚马逊公司创始人)<br>
我每天都自问: ‘如果今天是我生命的最后一天, 我还会做今天要做的事情吗?’ 如果连续很多天得到[否定]的回答, 那我就需要作出一些改变了; @乔布斯<br>
人生就像骑单车, 要保持平衡必须往前走 @爱因斯坦<br>
预测未来最好的方法就是去创造未来 @林肯 (美国前总统)<br>
没有人可以回到过去, 重新开始; 但谁都可以从现在开始, 书写一个全然不同的结局!<br>
人生最大的痛苦不是失败 而是没有经历自己想要经历的一切<br>
许多人所谓的成熟, 不过是被习俗磨去了棱角, 变得世故而实际了; 那不是成熟, 而是精神的早衰和个性的夭亡!	真正的成熟, 应当是独特个性的形成, 真实自我的发现, 精神上的结果和丰收; @&lt;在世纪的转折点上&gt;尼采 (哲学家 思想家)<br>
这辈子没法做太多的事情, 所以每一件都要做到精彩绝伦!	@乔布斯<br>
你的时间有限, 所以不要浪费时间去重复别人的生活!	Your time is limited, so don<code>t waste it living someone else</code>s life.	@乔布斯	<br>
每个人出生的时候都是原创 可悲的是很多人渐渐都成了盗版<br>
时间会刺破青春的华丽精致 会把平行线刻上美人的额角 会吃掉稀世之珍和天生丽质 什么都逃不过它横扫的镰刀	@莎士比亚<br>
死亡是生命中最好的发明 – 它把旧的清除以便给新的让路 @乔布斯<br>
一年之计 莫如树谷 十年之计 莫如树木	终身之计 莫如树人 @&lt;管子&gt;	<br>
非淡泊无以明志 非宁静无以致远 @&lt;淮南子&gt;刘安<br>
你若不想做, 总能找到借口 你若想做, 总会找到方法	@阿拉伯谚语<br>
想得到你从未拥有过的东西 就必须做你从未做过的事情<br>
你若失去了财产, 你只失去了一点儿; 你若失去了荣誉, 你就失去了许多; 你若失去了勇气, 你就把一切都失去了! @歌德<br>
那不能杀死我的, 使我更强! What does not kill me, makes me stronger. @尼采 (哲学家 思想家)<br>
对爱情的渴望, 对知识的追求, 对人类苦难不可遏制的同情心, 这三种纯洁而无比强烈的激情支配着我的一生; Three passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind.	@&lt;我为什么而活着&gt;罗素 (哲学家 数学家 思想家)<br>
围在城里的人想逃出来, 城外的人想冲进去; 对婚姻也罢, 职业也罢, 人生的愿望大都如此! @&lt;围城&gt;钱钟书<br>
授人以鱼不如授人以渔! 授人以鱼只救一时之急, 授人以渔则可解一生之需!<br>
兴趣是最好的老师 @爱因斯坦<br>
知识上的投资总能得到最好的回报 @富兰克林 (美国开国元勋 物理学家 作家)<br>
学习不是填满水桶, 而是点燃火焰!	Education is not the filling of a pail but the lighting of a fire. @叶芝 (爱尔兰诗人)<br>
我唯一能确定的就是自己的[无知] I know nothing except the fact of my ignorance. @苏格拉底 (哲学之父)<br>
真正的无知[不是]知识的贫乏 而是拒绝获取知识 @波普尔 (哲学家 思想家)<br>
读书是在别人思想的帮助下建立自己的思想	@尼古拉.鲁巴金 (作家)<br>
不要盲目地崇拜任何权威 – 因为你总能找到相反的权威 @罗素 (哲学家 数学家 思想家)<br>
不必为自己的独特看法而害怕 因为我们现在所接受的常识都曾是独特看法 @&lt;自由思想的十诫&gt;罗素 (哲学家 数学家 思想家)<br>
仅仅凭借信仰跟从就等于[盲从] To follow by faith alone is to follow blindly. @富兰克林 (美国开国元勋 物理学家 作家)<br>
想象力比知识更重要!	因为知识是有限的, 而想象力概括着世界的一切, 推动着进步, 并且是知识进化的源泉 @爱因斯坦<br>
要打破人的偏见比崩解一个原子还难! @爱因斯坦<br>
大多数人宁愿相信[美丽的谎言] 而不愿意直面[丑陋的真相]<br>
你要按你所想的去生活 否则你迟早会按你所生活的去想<br>
知人者智 自知者明 胜人者有力 自胜者强 @&lt;道德经&gt;<br>
大多数人宁愿死去也不愿思考,事实上他们也确实到死都没有思考 @罗素 (哲学家 数学家 思想家)<br>
对知识分子而言, 成为思维的精英比成为道德的精英更重要! @王小波(作家)<br>
编程的艺术就是处理复杂性的艺术 @Edsger Dijkstra (图灵奖得主)<br>
简单是可靠的先决条件 Simplicity is prerequisite for reliability. @Edsger Dijkstra (图灵奖得主)<br>
从不同的层次审视你的设计<br>
过早的优化是万恶之源 Premature optimization is the root of all evil. @Donald Knuth (图灵奖得主 算法大牛)<br>
自由不是想做什么就做什么; 自由是教会你不想做什么就可以不做什么!@&lt;实践理性批判&gt;康德 (哲学家 思想家)</p>
]]></content>
      <tags>
        <tag>quote</tag>
      </tags>
  </entry>
  <entry>
    <title>公考学习目录</title>
    <url>//ec35fce6.html</url>
    <content><![CDATA[<p><a href="https://www.kdocs.cn/l/ctYoDB9lU4o9?busstype=file_update&amp;from=docs&amp;source=docsWeb">公考学习目录</a></p>
<h1>时政新闻</h1>
<ol>
<li><a href="http://www.qstheory.cn/">求是网</a></li>
<li><a href="http://paper.people.com.cn/rmrb">人民日报</a>、<a href="http://cpc.people.com.cn/">中国共产党新闻网</a></li>
</ol>
<h1>网站：</h1>
<ol>
<li><a href="http://gongkao66688.edudisk.cn/">考公资源网盘gongkao666</a>：国省考资料，百度网盘</li>
<li><a href="https://docs.qq.com/sheet/DWFJaQXV4aUN2U0Rl?tab=BB08J2">学习资料</a>：资料丰富，基本都是夸克，更新很快，有很多其他资料。</li>
<li><a href="https://plan.zygwy.cn/">竹叶数据</a>:可以下载历年各省全国市公考真题，需要登录，其他功能需要付费</li>
<li><a href="https://www.gkzenti.cn/">真题网站</a> 哪里都能下看个人习惯</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>搭建hexo博客</title>
    <url>//8e88d59c.html</url>
    <content><![CDATA[<p><a href="https://blog.anheyu.com/posts/sdxhu.html">https://blog.anheyu.com/posts/sdxhu.html</a><br>
Eureka  <a href="https://lin64850.github.io/">https://lin64850.github.io/</a><br>
主题 <a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo教程</tag>
      </tags>
  </entry>
  <entry>
    <title>01. Raft 论文解读</title>
    <url>//e89635fc.html</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/ZFN_vKXVF30cJ1sPbJ3xBQ">从零实现 KV 和分布式 KV 有什么区别？</a><br>
在学习本节之前，最好先自己看一遍 <a href="https://raft.github.io/raft.pdf">Raft Paper</a>。如果英语不好，可以在网上搜翻译版来看。</p>
<h1>使用场景</h1>
<p>Raft 本质上是一种<strong>共识算法</strong>（consensus algorithm）。为什么要使用共识算法呢？什么场景下要使用共识算法呢？为什么共识算法逐渐成为了分布式系统的基石呢？</p>
<p>让我们来试着理一下内在逻辑：随着数字化的发展，当数据集（比如数据库中的一个 table）随着业务的增长，膨胀到一定地步之后，单机不再能存得下。因此需要将该数据集以某种方式切分成多个<strong>分片</strong>（Shard，也有地方称为 Partition、Region 等等）。分片之后，就可以将单个数据集分散到多个机器上。但是随着集群使用的机器数增多，整个集群范围内，<strong>单个机器的故障</strong>（各种软硬件、运维故障）概率就会增大。为了容忍机器故障、保证每个分片时时可用（可用性），我们通常会将分片<strong>冗余多份</strong>存在多个机器上，每个冗余称为一个<strong>副本</strong>（replication）。但如果分片持续有写入进来，从属于该分片的多个副本，由于机器故障、网络问题，就可能会出现数据不一致的问题。为了保证多副本间的数据一致性，我们引入了<strong>共识算法</strong>。</p>
<p><img src="./assets/1-1.png" alt=""></p>
<p>而我们要实现的 Raft 就是工业界当前一个主流共识算法，另一个是 Paxos。</p>
<h1>基本原理</h1>
<p>Raft 会将<strong>客户端请求</strong>序列化成操作序列，称为<strong>操作日志</strong>（operation log），继而会确保 Raft 的所有<strong>服务器</strong>（Server）会看到相同的日志。其中，每个 <strong>Raft</strong> <strong>Server</strong> 是一个进程，在工程中会各自在独立机器上，但课程中为了方便测试，会将其在单机上使用多线程模拟。Raft Server，也可称为 <strong>Raft Instance</strong>、<strong>Raft Peer</strong>，都是说的一个概念。</p>
<p>在工程实践中，通常一个 Raft Server 会包含多个数据分片的<strong>状态机</strong>（对应上文说的数据分片的一个副本），不同机器上从属于一个数据分片的副本联合起来组成一个 Raft Group，这样一个集群中就会存在多个 Raft Group。如 TiKV 的架构（他们的数据分片叫 Region）：</p>
<p><img src="./assets/1-2.png" alt="1-2"></p>
<p>但在本课程 Raft 部分中，我们只考虑最简单情况：一个 Raft Server 中只包含一个状态机。在后面 ShardKV 部分中，会扩展到类似 TiKV 的架构。</p>
<p>所有 Raft Server 初始状态为空，然后回按照按相同的顺序执行相同的客户端请求，进而保证状态机是一致的。如果某个 Raft Server 宕机重启后，进度落下了，Raft 算法会负责将其日志进行追平。只要有<strong>超过半数</strong>的 Peer 存活并且可以互相通信，Raft 就可以继续正常运行。如果当前没有多数派存活，则 Raft 将会陷入停滞，不能继续接受客户端来的请求。不过，一旦多数 Peer 重新可以互通，Raft 就又可以继续工作。</p>
<p>这里面涉及几个核心概念角色：</p>
<ol>
<li><strong>客户端（Client）</strong>：Raft 的客户端，会向 Raft 发送写请求。</li>
<li><strong>服务器（Raft Server，也称为 Raft Instance 或 Raft Peer）</strong>：组成 Raft 集群的单个进程。</li>
<li><strong>状态机（State Machine）</strong>：每个 Raft Server 中会有一个本地的状态机。所谓状态机，在本课程里，可以理解为一个小型的 KV 存储。客户端的读取请求，都会直接打到状态机中。</li>
</ol>
<p>三者关系可以参照<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">论文</a>中的图：</p>
<p><img src="./assets/1-3.png" alt="1-3"></p>
<p>图中的四个步骤含义如下：</p>
<ol>
<li><strong>写入</strong>：<strong>客户端</strong>向 Raft 发送写请求，写入数据</li>
<li><strong>同步</strong>：Raft 模块将请求序列化为日志，然后：
<ol>
<li>写入 <strong>Raft Server</strong> 本地 log</li>
<li>同步到其他 Raft 实例</li>
</ol>
</li>
<li><strong>应用</strong>：每个实例会将 Raft Log 各自应用到<strong>状态机</strong></li>
<li><strong>读取</strong>：客户端向状态机发送读请求，读取之前写入（状态机中）的数据</li>
</ol>
<p>其中为什么要以日志作为中间载体来维持一致性呢，可以看看 Kafka 创始人的一篇<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">文章</a>。</p>
<h1>实现概要</h1>
<p>在本课程中，我们将使用 Go 来实现 Raft —— 将每个 Raft 实例组织为一个 Go 的 struct，每个 Raft 实例在逻辑上会维护一个无限的<strong>操作序列</strong>（commands sequence），每个<strong>操作</strong>都有下标（从 1 开始的自增下标）。该下标类似于 TCP 中的序号，是我们在多机对操作序列达成共识的重要设计。每个操作也称为<strong>日志条目</strong>（log entry），一旦日志条目在多机达成共识，我们就可以对其进行<strong>提交</strong>（commit）。只有提交之后的日志，才能够被应用（apply）到状态机。</p>
<p>我们之后在进行实现时，要反复研读 <a href="https://raft.github.io/raft.pdf">Raft 扩展论文</a>，尤其是下面列出的图 2。该图在代码级别定义了我们所需要的数据结构和每个 RPC 的行为细节。论文中提到的大部分功能我们都会实现：领导选举、日志同步、宕机恢复、日志压缩。</p>
<p><img src="./assets/1-4.png" alt="1-4"></p>
<p><strong>配置变更</strong>（config changes）是指 Raft 中 Server 个数动态的增删，通常用于<strong>多个</strong> Raft Group 的分裂和合并（通常用于 Partition 的分裂与合并），因此实现了配置变更的 Raft 通常也称为 Multi-Raft。此部分较为复杂，我们本课程中不做实现。</p>
<p>在铺垫了基本概念之后，接下来我们来梳理下 Raft 算法细节。</p>
<p>相比 Paxos，Raft 的一大特色就是算法拆成了相对正交的几个部分——领导者选举、日志同步、状态持久化、日志压缩和配置变更。你如果对课程照目录看下就能看出来，除却最后一部分，这些模块就是我们课程 PartA ~ PartD 要分别实现的内容。将算法正交化拆分的好处是，让每个模块相对内聚，使得整体更易理解和实现——这也是 Raft 算法设计的初衷。</p>
<p>下面我不打算采用<strong>精确</strong>的方式来讲解每个模块——那是<strong>论文正文</strong>和<strong>代码实现</strong>要做的事情。相反，本章我将带领大家在<strong>感性</strong>上建立一个对 Raft 基本概念（任期、选举）和两大流程（领导选举、日志同步）的认识。带着这个感性认识，大家可以再去仔细研读<a href="https://raft.github.io/raft.pdf">论文</a>，想必能事半功倍地梳理出 Raft 算法中海量的细节。</p>
<h1>任期</h1>
<p><strong>任期</strong>（term）在任何共识协议中都很重要。Raft 中所有关键事件的展开，都是基于任期的，任期最直观的理解就是领导者任期，如“总统任期”。</p>
<p>但其本质上是一种关于时间隐喻，可以理解为“纪元”——如桃花源中的村民“不知有汉，无论魏晋”的那种朝代纪元。与桃花源村民相似，在 Raft 中，如果出现网络分区，某些 Peer 被隔绝，也很容易不知道其他 Peer 到了哪个 Term。一段时间后，被隔绝分区中的 Peer 与其他 Peer 重新建立通信（武陵人发现了他们）时，首先要做的就是对齐 Term，这是之后一切沟通展开的基础。</p>
<p>从另外一个角度讲，任期还是一种<strong>优先级</strong>或者<strong>权力</strong>的隐喻：</p>
<ol>
<li>低任期的 Peer 收到高任期的 Peer 任何信息后，会自动“跟上”（Follow）任期变成<strong>跟随者</strong>（Follower）。</li>
<li>高任期的 Peer 收到低任期 Peer 的任何<strong>请求</strong>时，会直接拒绝。</li>
</ol>
<p>在所有 Peer 进行“交流”（RPC 通信）时，任期都是第一优先级的，只有对齐了任期，才有谈其他的基础。</p>
<h1>领导选举</h1>
<p>Raft 使用的是“强人模式”，即只要 Leader 当选，他就对其任期内日志长啥样有说一不二的权力。Raft 中也采取“一山不容二虎”策略——一个任期内最多有一个 Leader（也可以没有选出）。但在同一时刻，可能会存在多个 Leader，但，他们一定处于不同任期中。</p>
<p>由于采用强人策略，则在选举时就要慎之又慎——以期能选出能“顾全大局”的人（具备所有已提交日志的候选者）。为此，每个 Peer 在投票时，都要比比谁的日志“更新更全”。一旦跟随者投出其票，就表示对该候选者心悦诚服——“承诺”一段时间内不会再发起选举（重置选举时钟）。</p>
<p>Leader 在当选后，要做的第一件事就是“昭告天下”（心跳）以“压制”其他“试图挑战权威”的人——“迫使”每个 Follower 承诺一段时间内不得再发起选举。Follower 在收到心跳后，只要任期不比人家大，就要乖乖给出“承诺”（重置选举时钟）。</p>
<p>之后，Leader 便会周期性的发送“政令”，直到收到来自高“任期”的消息，便要乖乖“交权”，让出领导权。从这里也可以看出，任期是第一优先级，这是“时间法则”的攻击，Leader 也不能免疫。当然，还有一种优化，就是 Leader 发现自己成为“孤家寡人”（发现大部分人不应答“政令”了，通常出现在 Leader 与多数 Follower 发生了网络隔离时）后，也自动交权。</p>
<h1>日志同步</h1>
<p>Leader 在接收到“甲方”（客户端）的“请求”后，会将其包装为“政令”（日志），然后“附带”到周期性的广播（心跳）上，将“政令灌输”给每个 Follower。最简单粗暴的方式，就是将本地所有日志一股脑的附带到心跳上，Follower 收到后，直接替换本地日志即可。但如果 Leader 日志量很大，通信代价将会非常高。因此 Leader 采用一种“乐观+回撤”的方式进行同步：</p>
<ol>
<li><strong>乐观</strong>：一开始心跳不附带任何日志，只带一些“暗号”过去。假如 Follower 的通过“暗号”发现自己日志跟 Leader 完全一致，就直接回：一致，之后的心跳不需附加任何日志。</li>
<li><strong>回撤</strong>：如果 Follower 通过“暗号”发现自己和 Leader 日志并不一致，也会告诉 Leader——下次得附带日志。则 Leader 就附加一些末尾的日志，如果发现还是不一致，就要继续回撤，多向前附加一些日志，同时更新“暗号”，直到收到 Follower 肯定回复，则继续恢复不附加任何日志的心跳。</li>
</ol>
<p>这个“暗号”，就是 Leader 所附带日志的的前一条日志信息的二元组：<code>&lt;下标，任期&gt;</code>。如果心跳没有附加任何日志，则暗号就是 Leader 最后一条日志的相关信息。为了保证 Leader 附带日志总有前一条日志，我们在对日志进行初始化的时候，会在开头放一条“空日志”，从而避免一些边界判断（这个做法类似带头结点的链表）。</p>
<p>那为什么只要“暗号”对的上，就能保证两方日志前缀一致呢？</p>
<p>简单来说，对“暗号”的过程，就是一个<strong>递推</strong>的过程。根据<strong>数学归纳法</strong>，每次附加新日志，都要对齐前序日志。而由任期单调递增、单任期最多一个 Leader，则同任期的日志前缀一定对得上。这样一来，同任期前缀对的上，跨任期同步前都会对齐前任日志，则“政令畅通”的情况下，所有日志最终都会收敛为 Leader 日志。</p>
<p>在“政令”（日志）同步到大多数节点后，Leader 就会宣布该政令“生效”（提交）。但论文特别强调了，Leader 不能直接宣布前任的“政令”生效，而要在本任期内发布“政令”后，通过“生效”本任期“政令”来间接“追认”前序任期的相关“政令”。这是为什么呢？（下图是 Raft 中大名鼎鼎的一张图“Figure 8”，很多实现 Raft 的同学应该都被该图虐过。）</p>
<p><img src="./assets/1-5.png" alt="1-5"></p>
<p>这是由于我们选举时会通过比最后一条日志的“大小”来决定是否 Leader 当选，因此前任的日志，如果没有通过本任期“盖棺定论”，是有可能被其他在相同下标具有更新日志的 Peer 当选 Leader 后“冲掉的”，也就是上图 c、d、e 的情况——没有 4 日志的“压一道”， S5 是可以当选 Leader 的，之后 S1~S3 的 2 日志是有可能被 S5 的 3 的日志冲掉。</p>
<blockquote>
<p>注意：这个图中 d 和 e 的结果是互斥的。其意思是如果我们在 c 中提交 2 是不对的，因为可能发生 d 中 2 被冲掉的情况；但是我们在 e 中通过提交 4 间接提交 2 就没有问题；</p>
</blockquote>
<h1>继续观看</h1>
<p>这里罗列了一些重要的参考资料，包括课程讲义中列出的、课程助教的博客和网上一些同学的分享记录等等。</p>
<ol>
<li>作者讲解：<a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw">https://www.youtube.com/watch?v=YbZ3zDzDnrw</a></li>
<li>论文原文：<a href="https://raft.github.io/raft.pdf">In Search of an Understandable Consensus Algorithm (Extended Version)</a></li>
<li>可视化 1：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></li>
<li>可视化 2：<a href="https://observablehq.com/@stwind/raft-consensus-simulator">https://observablehq.com/@stwind/raft-consensus-simulator</a></li>
<li>Raft Structure Advice：<a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt</a></li>
<li>Debugging by Pretty Printing：<a href="https://blog.josejg.com/debugging-pretty/">https://blog.josejg.com/debugging-pretty/</a></li>
<li>Students’ Guide to Raft ：<a href="https://thesquareplanet.com/blog/students-guide-to-raft/">https://thesquareplanet.com/blog/students-guide-to-raft/</a></li>
<li>An Introduction to Distributed Systems**：**<a href="https://github.com/aphyr/distsys-class">https://github.com/aphyr/distsys-class</a></li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>02. Raft 代码总览</title>
    <url>//da698a95.html</url>
    <content><![CDATA[<h1>概述</h1>
<p>通过 git 从<a href="https://github.com/storage-courses/raft-course.git">这个 repo</a> 拉下代码（如果你没有权限，请找作者加），切换到 <code>main</code> 分支，就可以在 <code>src/raft/raft.go</code> 中补充你的实现了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/storage-courses/raft-course.git</span><br></pre></td></tr></table></figure>
<p><code>raft.go</code> 中已经有一些框架代码和英文注释。所有测试代码在 <code>src/raft/test_test.go</code> 中，一共有 PartA~D 四个 Part，每个 Part 做完后测试通过之后再去做下一个 Part。Raft 部分所有样例实现在 <code>raft</code> 分支中，如果有遇到调试不过去的地方，可以切换过去参考。</p>
<p>举个例子，如果想切换到 PartA 的第二部分实现：<code>心跳逻辑[06.Raft PartA 心跳逻辑]</code>，可以通过 git log 看对应 commit id，然后 checkout 过去即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  raft git:(raft) git log</span><br><span class="line"></span><br><span class="line">commit 0fd60c1082deb9fb6d808254410df4b4ce84e30b</span><br><span class="line">Author: songpengwei &lt;songpengwei40@gmail.com&gt;</span><br><span class="line">Date:   Wed Oct 18 11:56:10 2023 +0100</span><br><span class="line"></span><br><span class="line">    PartA.Debug</span><br><span class="line"></span><br><span class="line">commit 77fc12edfaccb1b1a6d167219ba87e292c96df79</span><br><span class="line">Author: songpengwei &lt;songpengwei40@gmail.com&gt;</span><br><span class="line">Date:   Wed Oct 18 11:32:30 2023 +0100</span><br><span class="line"></span><br><span class="line">    PartA.3</span><br><span class="line"></span><br><span class="line">commit 4b8f56f2c71bc6cd05a11fbd7d7a19a4f3561666</span><br><span class="line">Author: songpengwei &lt;songpengwei40@gmail.com&gt;</span><br><span class="line">Date:   Wed Oct 18 10:25:39 2023 +0100</span><br><span class="line"></span><br><span class="line">    PartA.2</span><br><span class="line"></span><br><span class="line">commit f5331a604ac867990fe50476f3d604ef24cdd38e</span><br><span class="line">Author: songpengwei &lt;songpengwei40@gmail.com&gt;</span><br><span class="line">Date:   Tue Oct 17 17:07:20 2023 +0100</span><br><span class="line"></span><br><span class="line">    PartA.1</span><br><span class="line">    </span><br><span class="line">➜  raft git:(raft) git checkout 4b8f56f2c71bc6cd05a11fbd7d7a19a4f3561666</span><br></pre></td></tr></table></figure>
<p>最后，每一部分写完后，测试可以保证逻辑大体正确；加上<a href="https://go.dev/blog/race-detector"> -race 选项</a> 可以确保没有数据竞态。本实验出现数据竞态的主要原因，就是多个 goroutine 并发访问一个共享变量时，有的 goroutine 没有加锁。</p>
<h1>接口</h1>
<p>你在实现 Raft 时，主要需要对外提供以下接口，即所有测试依赖这些接口语义的正确实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 Raft 实例</span></span><br><span class="line">rf := Make(peers, me, persister, applyCh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就一个新的日志条目达成一致</span></span><br><span class="line">rf.Start(command <span class="keyword">interface</span>&#123;&#125;) (index, term, isleader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 询问 Raft 实例其当前的 term，以及是否自认为 Leader（但实际由于网络分区的发生，可能并不是）</span></span><br><span class="line">rf.GetState() (term, isLeader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次有日志条目提交时，每个 Raft 实例需要向该 channel 发送一条 apply 消息</span></span><br><span class="line"><span class="keyword">type</span> ApplyMsg</span><br></pre></td></tr></table></figure>
<p>服务通过调用 <code>Make(peers, me, persister, applyCh)</code> 创建一个 Raft Peer。其中 peers 是所有参与 Raft Group 的对端句柄数组，通过这些句柄，可以给所有 Peer 发送 RPC。<code>me</code> 是本 Raft Peer 在数组中的下标，测试会保证所有 Raft Peer 看到的数组中元素顺序是一致的。</p>
<p><code>Start(command)</code> 是应用要求 Raft Group 提交一条日志，该函数是异步的，要立即返回，而无需等待日志提交后再返回。通过论文我们知道，只有 Leader 才能提交日志，因此如果不是 Leader 的 Peer 收到此调用后，立即返回说自己不是 Leader 即可。如果是 Leader 且最终提交成功，会通过 Make 时传入的 <code>applyCh</code> 将消息返回给应用层。</p>
<p><code>GetState()</code> 是应用层用于确定当前 Raft Peer 的任期和状态。</p>
<h1>RPC</h1>
<p>labrpc 是用于模拟复杂网络环境（延迟、乱序、丢包）的一个小 RPC 库，工业中性能肯定不够用。但在本课程中，为了方便在单机模拟复杂的分布式环境，这个库非常重要。</p>
<p>RPC 是使用了 Client-Server 模式，Client 端构造参数，发送 RPC 请求；Server 端接受请求，进行处理，构造返回值。labrpc 帮我们实现了大部分逻辑，对于一个 RPC 请求，我们只需要实现：</p>
<ol>
<li>定义请求参数和返回值结构体</li>
<li>实现 Client 侧的发送逻辑</li>
<li>实现 Server 侧的回调函数</li>
</ol>
<p>下面以领导者选举的 RPC 为例，说明下如何使用这个框架。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example RequestVote RPC handler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example code to send a RequestVote RPC to a server.</span></span><br><span class="line"><span class="comment">// server is the index of the target server in rf.peers[].</span></span><br><span class="line"><span class="comment">// expects RPC arguments in args.</span></span><br><span class="line"><span class="comment">// fills in *reply with RPC reply, so caller should</span></span><br><span class="line"><span class="comment">// pass &amp;reply.</span></span><br><span class="line"><span class="comment">// the types of the args and reply passed to Call() must be</span></span><br><span class="line"><span class="comment">// the same as the types of the arguments declared in the</span></span><br><span class="line"><span class="comment">// handler function (including whether they are pointers).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The labrpc package simulates a lossy network, in which servers</span></span><br><span class="line"><span class="comment">// may be unreachable, and in which requests and replies may be lost.</span></span><br><span class="line"><span class="comment">// Call() sends a request and waits for a reply. If a reply arrives</span></span><br><span class="line"><span class="comment">// within a timeout interval, Call() returns true; otherwise</span></span><br><span class="line"><span class="comment">// Call() returns false. Thus Call() may not return for a while.</span></span><br><span class="line"><span class="comment">// A false return can be caused by a dead server, a live server that</span></span><br><span class="line"><span class="comment">// can&#x27;t be reached, a lost request, or a lost reply.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Call() is guaranteed to return (perhaps after a delay) *except* if the</span></span><br><span class="line"><span class="comment">// handler function on the server side does not return.  Thus there</span></span><br><span class="line"><span class="comment">// is no need to implement your own timeouts around Call().</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// look at the comments in ../labrpc/labrpc.go for more details.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// if you&#x27;re having trouble getting RPC to work, check that you&#x27;ve</span></span><br><span class="line"><span class="comment">// capitalized all field names in structs passed over RPC, and</span></span><br><span class="line"><span class="comment">// that the caller passes the address of the reply struct with &amp;, not</span></span><br><span class="line"><span class="comment">// the struct itself.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendRequestVote(server <span class="type">int</span>, args *RequestVoteArgs, reply *RequestVoteReply) <span class="type">bool</span> &#123;</span><br><span class="line">        ok := rf.peers[server].Call(<span class="string">&quot;Raft.RequestVote&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，每个 RPC 基本包括四部分：</p>
<ol>
<li>请求参数：<code>RequestVoteArgs</code></li>
<li>请求回复：<code>RequestVoteReply</code></li>
<li>回调函数：<code>RequestVote</code></li>
<li>发送请求：<code>sendRequestVote</code></li>
</ol>
<p>需要注意：</p>
<ol>
<li>请求 <code>RequestVoteArgs</code> 和回复 <code>RequestVoteReply</code> 中所有字段必须大写，否则没法导出（参见 <a href="https://go.dev/doc/effective_go#names">golang 的命名规则</a>），为 <code>labrpc</code> 所解析。</li>
<li>RPC 接收方（Server 端），收到 RPC 后，labrpc 库会自动调用回调函数  <code>RequestVote</code></li>
<li>RPC 发送方（Client 端），通过调用指定下标的 Peer 在 Make 中传入的句柄参数，以名字的方式 <code>Raft.RequestVote</code> （即这里的名字和回调函数的函数名一定<strong>要一致</strong>，并且要加上 Raft 前缀）来具体定位到 Server 端的对应回调函数。至于如何根据句柄找到对端 Raft Peer、如何将请求打过去、如何序列化和反序列化请求、如何在 Server 端调用回调函数，都是 labrpc 框架做的事情，我们无需关心。</li>
</ol>
<p>下面说一下我们如何来组织 Raft 代码，可以从两个角度来鸟瞰式地纵览 Raft：</p>
<ol>
<li>三个工作流</li>
<li>一个状态机</li>
</ol>
<h1>工作流</h1>
<p>所谓工作流，就是一个处理逻辑闭环，可以粗浅理解为一个循环（ loop），因此要分别独占一个线程。循环中通常要做一些事情，通常由两种方式触发：</p>
<ol>
<li><strong>时钟触发（time-driven）</strong>：周期性地做某件事，比如 Leader -&gt; Follower 的发送日志。</li>
<li><strong>事件触发（event-driven）</strong>：条件满足时做某件事，比如当 <code>commitIndex</code> &gt; <code>applyIndex</code> 时，需要 apply 已经提交的日志。</li>
</ol>
<h2 id="实现思路">实现思路</h2>
<p>每个工作流使用一个线程来实现，线程的最外层逻辑就是一个循环。循环当然总有个退出条件，对于 raft 来说，就是是否已经被 killed。</p>
<p>对于时钟触发（time-driven）的工作流，在 golang 中，我们至少有两种方式可以控制触发：</p>
<ol>
<li><code>time.Sleep </code></li>
<li><code>time.Ticker</code> 和 <code>time.Timer</code></li>
</ol>
<p>方法 2 会涉及 <strong>golang Channels</strong> 和回调函数，使用起来相对复杂，不建议新手用。因此，我们选用方法 1，实现起来就很自然，比如发送一轮日志后，就调用 <code>time.Sleep </code> 沉睡一个心跳周期。</p>
<p>对于事件触发（event-driven）的工作流，在 golang 中，我们也至少有两种方式可以控制：</p>
<ol>
<li><code>sync.Cond</code></li>
<li><code>Channel</code></li>
</ol>
<p>这里我们选用 <code>sync.Cond</code> ，因为可以配合锁使用，以保护一些使用共享变量的<strong>临界区</strong>。而 Channel 只能做简单的唤醒，并不能和锁配合使用。</p>
<p>一个 Raft 实例（Raft Peer）的主要有三个工作流：</p>
<ol>
<li>领导选举（leader election）</li>
<li>日志同步（ log replication）</li>
<li>日志应用（log application）</li>
</ol>
<p>其中前两个是时钟触发，最后一个是事件触发。下面将逐个结合代码来说明。</p>
<h2 id="领导选举">领导选举</h2>
<p>遵循 lab 中给出的命名方式，我们将所有的工作流称为 <code>xxxTicker</code> （滴答滴答，时钟触发），我个人习惯也常称为 <code>xxxLoop</code>。主要逻辑，就是一个大的 <code>for</code> 循环，隔一段时间 <code>time.Sleep(time.Duration(ms) * time.Millisecond)</code>就进行一次检查，看<strong>选举时钟</strong>否超时。如果超时，会转变为 Candidate，并发起选举。</p>
<p>我们这里并没有真的使用一个时钟（比如 <code>time.Timer</code>），原因如前所述。而是每次时钟重置时，就重置计时起点：<code>rf.electionStart</code> 为当前时刻 <code>time.Now()</code> 。这样，每次循环检查时，如果检查时间点与计时起点的差值大于<strong>选举超时间隔</strong>，则进入选举流程<code>rf.startElection()</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> electionTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Your code here (PartA)</span></span><br><span class="line">                <span class="comment">// Check if a leader election should be started.</span></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> rf.role != Leader &amp;&amp; rf.isElectionTimeoutLocked() &#123;</span><br><span class="line">                        rf.becomeCandidateLocked()</span><br><span class="line">                        <span class="keyword">go</span> rf.startElection(rf.currentTerm)</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// pause for a random amount of time between 50 and 350</span></span><br><span class="line">                <span class="comment">// milliseconds.</span></span><br><span class="line">                ms := <span class="number">50</span> + (rand.Int63() % <span class="number">300</span>)</span><br><span class="line">                time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选举的过程，粗略来说，就是逐一向所有其他 Peer 发送“要票”（RequestVote） RPC，然后看是否能获得多数票以决定是否当选。当然，还有很多细节没有讲，此处不再展开，后面会有<code>专门一节[05.Raft PartA 选举逻辑]</code>来讲。这里与代码组织相关，值得一提的是如何处理 RPC。</p>
<p>现实中 raft 的要票请求 RPC 通常会走网络（虽然本实验是在单机模拟的），而网络通信有诸多不可靠之处：</p>
<ol>
<li>请求可能在途中丢失</li>
<li>请求可能无限阻塞</li>
<li>对端机器可能宕机</li>
<li>对端机器可能很慢</li>
<li>…</li>
</ol>
<p>总之，RPC 耗时很不确定，因此不能<strong>同步</strong>地放到 <code>electionTicker</code> 中，每个 RPC 需要额外启动一个 goroutine 来执行。</p>
<h2 id="日志同步">日志同步</h2>
<p>日志同步的工作流和领导选举很像，但又有所不同：</p>
<ol>
<li><strong>生命周期不同</strong>。领导选举的工作流会持续整个 raft 实例的存活周期；而日志同步地工作流只会持续它当选为领导的那个<strong>任期</strong>（ term）。之后如果再当选，会重新启动一个工作流。</li>
<li><strong>超时间隔不同</strong>。领导选举的超时间隔是在一个小范围内随机的；而日志同步地超时间隔是固定的。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tick only span for one term.</span></span><br><span class="line"><span class="comment">// That is, if term changed, the ticker will end.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicationTicker(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                contextRemained := rf.startReplication(term)</span><br><span class="line">                <span class="keyword">if</span> !contextRemained &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                time.Sleep(replicateInterval)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="日志应用">日志应用</h2>
<p>只要理解了 <code>sync.Cond</code> 的使用（我们在<code>多线程编程[附录 1]</code>那一节讲过），日志应用的工作流是比较简单的：当条件满足时，遍历相关日志，逐个 apply。由于 apply 需要将 msg 逐个送到 channel 中，而 channel 耗时是不确定的，因此需要放到临界区外。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applicationTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.applyCond.Wait()</span><br><span class="line">                entries := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">                        entries = <span class="built_in">append</span>(entries, rf.log[i])</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">                        rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                                CommandValid: entry.CommandValid,</span><br><span class="line">                                Command:      entry.Command,</span><br><span class="line">                                CommandIndex: rf.lastApplied + <span class="number">1</span> + i, <span class="comment">// must be cautious</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.lastApplied += <span class="built_in">len</span>(entries)</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>状态机</h1>
<p>每个 Peer 都会在三个角色：<code>Follower</code>，<code>Candidate</code> 和 <code>Leader</code> 间变换，当条件满足时，就会从一个角色变为另一个角色。</p>
<p><img src="./assets/2-1.png" alt="2-1"></p>
<p>状态机没问题，候选人在发现同任期领导人后会转换成 Follower，录屏中口误。</p>
<p>可以根据这三个状态抽象出三个函数：<code>becomeFollower</code>，<code>becomeCandidate</code>，<code>becomeLeader</code>，即驱动状态机的“线”。并且增加一些限制，禁止一些图中不存在的“线”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeFollowerLocked(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> term &lt; rf.currentTerm &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.role = Follower</span><br><span class="line">        shouldPersist := term != rf.currentTerm</span><br><span class="line">        <span class="keyword">if</span> term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.votedFor = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.currentTerm = term</span><br><span class="line">        <span class="keyword">if</span> shouldPersist &#123;</span><br><span class="line">                rf.persistLocked()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeCandidateLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role == Leader &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.currentTerm++</span><br><span class="line">        rf.role = Candidate</span><br><span class="line">        rf.votedFor = rf.me</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeaderLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role != Candidate &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.role = Leader</span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                rf.nextIndex[peer] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">                rf.matchIndex[peer] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>Locked</code> 的后缀，说明该函数必须在锁的保护下调用，因为函数内部并没有加锁。另外，还可以加一些适当的日志，表明角色的转换过程，在进行调试时，角色转换时最重要的信息之一。</p>
<h1>具体实现</h1>
<p>如果一次性实现 Raft 将会非常复杂，且很难一次性写对，因此我们将其分成四个部分来增量式的实现。Raft 最主要的逻辑就是领导者选举和日志同步，因此可以分别作为一个部分；之后，为了应对宕机重启，需要再实现 Raft 状态持久化和恢复逻辑；最后，随着写入的不断增多，日志会越来越大，照论文中的方案，我们会对之前的状态定时 snapshot，就可以将 snapshot 对应的老旧日志截断，只保留 snapshot 之后最新的日志。</p>
<p>简单来说，四个部分的分工大概是：</p>
<ol>
<li><strong>Part A：领导者选举</strong>：但不带日志比较</li>
<li><strong>Part B：日志同步</strong>：同时完善领导选举，比较日志</li>
<li><strong>Part C：状态持久化</strong>：将所有影响逻辑的状态外存</li>
<li><strong>Part D：日志压缩</strong>：做 snapshot</li>
</ol>
<p>每个部分通过测试后再进行下一部分，这种思想也是构建大型工程常用的：先跑通一个最小可用模型，然后通过测试保证正确后，再不断增量式迭代增加功能，每次都通过测试来保证增量部分的正确性。</p>
<h1>参考</h1>
<ol>
<li>Raft Structure Advice：<a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt</a></li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>03. Raft PartA 领导者选举</title>
    <url>//66d80af5.html</url>
    <content><![CDATA[<h1>实现要求</h1>
<p>实现 Raft 选举和<strong>心跳逻辑</strong>（即不带日志条目的 AppendEntries）。本部分仅要求实现：</p>
<ol>
<li>选出<strong>唯一</strong>的领导者，领导者选出后会持续进行心跳避免其他人发起选举</li>
<li>旧的领导者宕机或者网络故障无法触达时，选出<strong>新的</strong>领导者</li>
</ol>
<p>PartA 并不需要实现日志同步逻辑，连带着在收到选举请求时，也都先忽略比较日志新旧的逻辑。</p>
<p>写完后在 <code>src/raft</code> 文件夹，使用 <code>go test -run PartA -race</code> 来测试代码逻辑是否正确、是否有数据竞态。</p>
<h1>实现要点</h1>
<p>下面罗列下实现概要：</p>
<ol>
<li>遵照论文图 2 进行实现，但当前只需要关心收发 <code>RequestVote</code> 请求、选举相关的规则和状态转换</li>
<li><strong>选举逻辑</strong>：填充 <code>RequestVoteArgs</code> 和 <code>RequestVoteReply</code> 结构体。修改 <code>Make()</code> 函数，在创建 Raft Peer 的时候，创建超时检测、发起选举的后台 goroutine。实现 <code>RequestVote()</code> 回调函数，以在 Leader 要票时进行投票。</li>
<li><strong>心跳逻辑</strong>：为了保证 Leader 当选后压制其他 Peer 再次发起选举，你需要定义 <code>AppendEntriesArgs</code> 和 <code>AppendEntriesReply</code> 结构体，但暂时并不需要填充字段，因为 PartA 你并不需要实现日志同步逻辑。只需要实现 <code>AppendEntries()</code> 回调函数，在收到 <code>AppendEntries</code> RPC 请求时，重置选举计时器即可。</li>
<li><strong>随机超时</strong>：论文中着重强调了，为了避免“活锁”——每个人都不断地选自己，需要让选举超时是随机的。可以使用 golang 的 <a href="https://pkg.go.dev/math/rand">rand</a> 包来制造随机超时。</li>
<li><strong>测试限制1</strong>：测试代码要求 Leader 每秒不能发超过几十次的心跳 RPC，也即你的心跳间隔不能太小。论文中的 5.2 小节提到过选举超时可以选取 150ms ~ 300ms 的超时间隔，这意味着你的心跳间隔不能大于 150ms（否则不能压制其他 Peer 发起选举）。当然，你可以不按照论文来，适当调大选举超时范围，但也不能太大，原因见下一条。</li>
<li><strong>测试限制2</strong>：测试代码要求在多数节点存活时，必须在 5s 内选出 Leader。需要注意的是，即使多数节点都存活，也不一定在一个轮次的选举 RPC 就能选出主（比如很小概率的有两个 Peer 同时发起选举并造成平票），因此要仔细选取选举超时参数，不能太大，否则规定时间内选不出 Leader。</li>
<li><strong>轮询检查</strong>：后台 goroutine 需要不断轮询检查是否需要发起选举，golang 的初学者最好使用  for loop + <a href="https://pkg.go.dev/time#Sleep">sleep</a> 的形式组织代码，不容易出错、且易于调试。当然，你如果是 golang 大师，可以考虑使用 <code>time.Timer</code> 或者 <code>time.Ticker</code>。</li>
<li>如果你的代码通不过测试，可以反复揣摩论文中图 2 中的逻辑。但虽然图 2 给出了所有实现要点，但是并没有按照实现顺序给出，还需要自己组织合理的逻辑顺序以及控制流。</li>
<li>不要忘记实现 <code>GetState()</code> 函数，否则 tester 没有办法知道选出了 Leader。</li>
<li>当 tester 结束测试时，会调用 <code>rf.Kill()</code> 设置标记位 <code>rf.dead</code> ，来告诉 Raft 可以退出了。你最好在所有后台线程都去检查该标志位，否则可能会在结束测试时打出一些奇怪日志。</li>
<li>RPC 字段：golang 在进行 RPC 时，只会序列化所有大写字母开头的字段，因此一定要注意在定义 <code>*Args</code> （如 <code>RequestVoteArgs</code>）和  <code>*Reply</code> 结构体的时候，确保所有字段首字母都是大写的，否则没有办法通过 RPC 传到对端 Peer。</li>
</ol>
<p>到此，你就可以自己写代码做测试了，后面部分是实现部分，建议看到这里后，先自己实现一遍，然后跑测试。哪怕最终做不出来也先趟趟雷，才能带着问题去理解为什么要那么实现。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>05. Raft PartA 选举逻辑</title>
    <url>//f6c558d8.html</url>
    <content><![CDATA[<p>我们以三个层次组织 RPC <strong>发送方</strong>（也就是 Candidate）<strong>要票逻辑</strong>：</p>
<ol>
<li><strong>选举 loop</strong>：但按框架默认的命名方式，我们称之为 <code>electionTicketor</code></li>
<li><strong>单轮选举</strong>：超时成为 Candidate 之后，针对所有 Peer（除自己外）发起一次要票过程，我们称之为 <code>startElection</code>。</li>
<li><strong>单次 RPC</strong>：针对每个 Peer 的 RequestVote 的请求和响应处理，由于要进行计票，需要用到一个局部变量 votes，因此我们使用一个<code>startElection</code> 中的嵌套函数来实现，称为 <code>askVoteFromPeer</code>。</li>
</ol>
<p>还剩一块，就是 RPC <strong>接受方</strong>（其他 Peer）的<strong>投票逻辑</strong>。</p>
<h1>选举 Loop</h1>
<p>基本逻辑是每次在循环时，要进行两项检查：</p>
<ol>
<li><strong>超时检查</strong>：看<strong>选举 Timer</strong> 是否已经超时，只有超时后才会真正发起选举。这里有个问题，就是为什么检查间隔（也就是循环中的 <code>time.Sleep(time.Duration(ms) * time.Millisecond)</code> ）间隔也是随机的？因为只有检查间隔也随机才不会造成：超时间隔随机，但由于“等距”检查，造成同样检查间隔时，一同发起选举。</li>
<li><strong>角色检查</strong>：判断是否为 Leader，如果自己已经是 Leader，则自然不用发起选举。因为发起选举的<strong>唯一目的就是当选 Leader</strong>。</li>
</ol>
<p>因此，我们要实现的第一个逻辑就是：随机超时上下界配置和超时检测函数。可以将选举超时间隔的上下界定义在最开始，后面调试的过程中如果发现该参数设置不合适，可以很方便地找到并修改。至于这两个上下界如何选，可以参考 PartA 实现要点(03.Raft PartA 领导者选举)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        electionTimeoutMin time.Duration = <span class="number">250</span> * time.Millisecond</span><br><span class="line">        electionTimeoutMax time.Duration = <span class="number">400</span> * time.Millisecond</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> resetElectionTimerLocked() &#123;</span><br><span class="line">        rf.electionStart = time.Now()</span><br><span class="line">        randRange := <span class="type">int64</span>(electionTimeoutMax - electionTimeoutMin)</span><br><span class="line">        rf.electionTimeout = electionTimeoutMin + time.Duration(rand.Int63()%randRange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> isElectionTimeoutLocked() <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time.Since(rf.electionStart) &gt; rf.electionTimeout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>满足条件时，转变为 Candidate ，然后异步地（同步会造成主 Loop 检查延迟）发起选举。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> electionTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                <span class="comment">// Your code here (PartA)</span></span><br><span class="line">                <span class="comment">// Check if a leader election should be started.</span></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> rf.role != Leader &amp;&amp; rf.isElectionTimeoutLocked() &#123;</span><br><span class="line">                        rf.becomeCandidateLocked()</span><br><span class="line">                        <span class="keyword">go</span> rf.startElection(rf.currentTerm)</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// pause for a random amount of time between 50 and 350</span></span><br><span class="line">                <span class="comment">// milliseconds.</span></span><br><span class="line">                ms := <span class="number">50</span> + (rand.Int63() % <span class="number">300</span>)</span><br><span class="line">                time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有用到 Raft 全局变量的地方都要加锁，但注意不要在加锁时进行<strong>同步地</strong>发送RPC。</p>
<p>该 Loop 的生命周期和 Raft Peer 相同，即<strong>在创建 Raft 实例时就在后台开始运行</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// some code are omitted here</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// start ticker goroutine to start elections</span></span><br><span class="line">        <span class="keyword">go</span> rf.electionTicker()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>单轮选举</h1>
<p>一轮选举包括针对除自己外所有 Peer 的一轮要票 RPC，由于需要访问全局变量，所以仍然要加锁。同样的，就不能在持有锁的时候，同步地进行 RPC。需要用 goroutine 异步地对每个 Peer 进行 RPC。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        votes := <span class="number">0</span></span><br><span class="line">        askVoteFromPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">                <span class="comment">// send rpc to `peer` and handle the response</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// every time locked </span></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Candidate, term) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        votes++</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                args := &amp;RequestVoteArgs&#123;</span><br><span class="line">                        Term:        term,</span><br><span class="line">                        CandidateId: rf.me,</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">go</span> askVoteFromPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="上下文检查">上下文检查</h2>
<p>这里面有个检查“上下文”是否丢失的关键函数：<code>contextLostLocked</code> <strong>。上下文</strong>，在不同的地方有不同的指代。在我们的 Raft 的实现中，“上下文”就是指 <code>Term</code> 和 <code>Role</code>。即在一个任期内，只要你的角色没有变化，就能放心地<strong>推进状态机</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> contextLostLocked(role Role, term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(rf.currentTerm == term &amp;&amp; rf.role == role)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多线程环境中，只有通过锁保护起来的<strong>临界区</strong>内的代码块才可以认为被原子地执行了。由于在 Raft 实现中，我们使用了大量的 goroutine，因此每当线程新进入一个临界区时，要进行 Raft 上下文的检查。如果 Raft 的上下文已经被更改，要及时终止 goroutine，避免对状态机做出错误的改动。</p>
<h1>单次 RPC</h1>
<p>单次 RPC 包括<strong>构造 RPC 参数、发送 RPC等待结果、对 RPC 结果进行处理</strong>三个部分。构造参数我们在 <code>startElection</code> 函数内完成了，因此 <code>askVoteFromPeer</code> 函数中就只需要包括后梁部分即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">askVoteFromPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">        <span class="comment">// send RPC</span></span><br><span class="line">        reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">        ok := rf.sendRequestVote(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// handle the response</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;Ask vote from %d, Lost or error&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the context</span></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Candidate, rf.currentTerm) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;Lost context, abort RequestVoteReply in T%d&quot;</span>, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// count votes</span></span><br><span class="line">        <span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">                votes++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> votes &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">                rf.becomeLeaderLocked()</span><br><span class="line">                <span class="keyword">go</span> rf.replicationTicker(term)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对齐任期">对齐任期</h2>
<p>在接受到 RPC 或者处理 RPC 返回值时的第一步，就是要<strong>对齐 Term</strong>。因为 Term 在 Raft 中本质上是一种“优先级”或者“权力等级”的体现。<strong>Peer 的 Term 相同，是对话展开的基础</strong>，否则就要先对齐 Term：</p>
<ol>
<li><strong>如果对方 Term 比自己小</strong>：无视请求，通过返回值“亮出”自己的 Term</li>
<li><strong>如果对方 Term 比自己大</strong>：乖乖跟上对方 Term，变成最“菜”的 Follower</li>
</ol>
<p>对齐 Term 之后，还要检查上下文，即处理 RPC （RPC 回调函数也是在其他线程调用的）返回值和处理多线程本质上一样：都要首先确保<strong>上下文</strong>没有丢失，才能驱动状态机。</p>
<blockquote>
<p><strong>Q：为什么要检查上下文？都需要在什么地方检查上下文？</strong></p>
<p>A：你可以这么理解，如果一件事情在一把锁的保护下<strong>不中断地</strong>做，那我们并不需要检查上下文。但是很多时候我们得进行一些耗时操作（如 RPC），此时需要把锁临时断开。之后，重新上锁时，你就得考虑，当前的状态是否满足我们之前期望的状态（也即“上下文”是否被维持了）——因为你的锁中间断开了，所以有些状态可能被其他线程给修改了。</p>
</blockquote>
<h1>回调函数</h1>
<p>所有 Peer 在运行时都有可能收到要票请求，<code>RequestVote</code> 这个回调函数，就是定义该 Peer 收到要票请求的处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA, PartB).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        <span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject vote, higher term, T%d&gt;T%d&quot;</span>, args.CandidateId, rf.currentTerm, args.Term)</span><br><span class="line">                reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.currentTerm &lt; args.Term &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the votedFor</span></span><br><span class="line">        <span class="keyword">if</span> rf.votedFor != <span class="number">-1</span> &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject, Already voted S%d&quot;</span>, args.CandidateId, rf.votedFor)</span><br><span class="line">                reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">        rf.votedFor = args.CandidateId</span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d&quot;</span>, args.CandidateId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调函数实现的一个关键点，还是要先对齐 Term。不仅是因为这是之后展开“两个 Peer 对话”的基础，还是因为在对齐 Term 的过程中，Peer 有可能重置 <code>votedFor</code>。这样即使本来由于已经投过票了而不能再投票，但提高任期重置后，在新的 Term 里，就又有一票可以投了。</p>
<p>还有一点，论文里很隐晦地提到过：<strong>只有投票给对方后，才能重置选举 timer</strong>。换句话说，在没有投出票时，是不允许重置选举 timer 的。从<strong>感性</strong>上来理解，只有“<strong>认可对方的权威</strong>”（发现对方是 Leader 或者投票给对方）时，才会重置选举 timer —— 本质上是一种“<strong>承诺</strong>”：认可对方后，短时间就不再去发起选举争抢领导权。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>04. Raft PartA 状态转换</title>
    <url>//bb4df00d.html</url>
    <content><![CDATA[<h1>实现概要</h1>
<p>该实验虽然功能最简单，但作为第一个实验，需要熟悉环境上手、构建整体代码框架(Raft 代码总览)、掌握用锁技巧(附录1)、掌握打日志方法和调试技术(附录2)，因此需要花费的精力却可能最多。</p>
<p>本节主要实现<strong>不带日志</strong>的选主逻辑。对于两个主要逻辑来说：</p>
<ol>
<li><code>AppendEntries</code> RPC 请求只负责通过心跳压制其他 Peer 发起选举，心跳中<strong>不包含</strong>日志数据。</li>
<li><code>RequestVote</code> RPC 请求中只会比较 term，会跳过谁的日志更 up-to-date 的比较。</li>
</ol>
<p>在学习完<code>代码框架(02.Raft 代码总览)</code>一章感受了基本代码框架之后，我们可以将 PartA 的实现分为三部分：</p>
<ol>
<li><strong>状态转换</strong>：角色定义和三个状态转换函数</li>
<li><strong>选举逻辑</strong>：定义选举 RPC 相关结构体，构造周期性发送请求的 Loop</li>
<li><strong>心跳逻辑</strong>：定义心跳 RPC 相关结构体（只有心跳，因此不涉及日志），当选 Leader 后发送心跳</li>
</ol>
<p>在开始实现逻辑之前，要根据[论文图 2]定义 Raft 用到的基本数据结构，如前所述，PartA 暂时不用管日志相关字段和逻辑。下面代码中，上面部分是代码框架为了测试默认给的，加粗部分是本部分新加的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">        mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">        peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">        persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">        me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">        dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Your data here (PartA, PartB, PartC).</span></span><br><span class="line">        <span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line">        <span class="comment">// state a Raft server must maintain.</span></span><br><span class="line">        role        Role</span><br><span class="line">        currentTerm <span class="type">int</span></span><br><span class="line">        votedFor     <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// used for election loop</span></span><br><span class="line">        electionStart   time.Time</span><br><span class="line">        electionTimeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：在工程实践中，<code>currentTerm</code> 一般会建议用指定位数的整形，比如 <code>int32</code>，但这里为了简单就直接用 <code>int</code> 了。</p>
<p>修改关键函数 <code>GetState</code>，是测试框架能够正确拿到 Raft 相关状态，否则可能会出现测试框架认为一直选不出主的情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return currentTerm and whether this server</span></span><br><span class="line"><span class="comment">// believes it is the leader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> rf.currentTerm, rf.role == Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>状态转换</h1>
<p>状态转换是针对 Peer 角色的，因此需要先定义<strong>角色类型</strong>和<strong>常量</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Role <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        Follower  Role = <span class="string">&quot;Follower&quot;</span></span><br><span class="line">        Candidate Role = <span class="string">&quot;Candidate&quot;</span></span><br><span class="line">        Leader    Role = <span class="string">&quot;Leader&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在此之上，参考论文中的状态机构建状态转换函数。</p>
<p><img src="./assets/2-1.png" alt="2-1"></p>
<p>可以实现为三个状态转换函数：<code>becomeCandidate</code>，<code>becomeLeader</code> 和 <code>becomeFollower</code>。由于涉及修改 Raft 的全局状态，需要加锁，且我们期望在函数外边加锁。按照之前提到的<a href="https://av6huf2e1k.feishu.cn/docx/EGLad8DZ0olT50xZQOdcZhEgnvg#GzH1d5k72oP0BXxQmWjc1ESQnib">命名规则</a>，对每个函数需要带上 <code>Locked</code> 后缀，表明需要在加锁的临界区中调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// become a follower in `term`, term could not be decreased</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeFollowerLocked(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DError, <span class="string">&quot;Can&#x27;t become Follower, lower term&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;%s -&gt; Follower, For T%d-&gt;T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm, term)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// important! Could only reset the `votedFor` when term increased</span></span><br><span class="line">        <span class="keyword">if</span> term &gt; rf.currentTerm &#123; </span><br><span class="line">                rf.votedFor = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.role = Follower</span><br><span class="line">        rf.currentTerm = term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeCandidateLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role == Leader &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DError, <span class="string">&quot;Leader can&#x27;t become Candidate&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;%s -&gt; Candidate, For T%d-&gt;T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm, rf.currentTerm+<span class="number">1</span>)</span><br><span class="line">        rf.role = Candidate</span><br><span class="line">        rf.currentTerm++</span><br><span class="line">        rf.votedFor = rf.me</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeaderLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role != Candidate &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLeader, </span><br><span class="line">                    <span class="string">&quot;%s, Only candidate can become Leader&quot;</span>, rf.role)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;%s -&gt; Leader, For T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm)</span><br><span class="line">        rf.role = Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，每个状态转换函数可分为两部分：</p>
<ol>
<li><strong>状态检查</strong>：检查 Raft 实例当前状态，看是否满足状态转换条件。</li>
<li><strong>状态修改</strong>：修改 Raft 实例角色，更改相应状态。</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>07. Raft PartA 调试和小结</title>
    <url>//fa2cd3f6.html</url>
    <content><![CDATA[<p>经过调试发现，视频代码主要有几个问题：</p>
<ol>
<li><code>startReplication</code> 落了一个返回值</li>
<li>日志打印有点问题</li>
<li><code>GetState</code> 函数没有实现。</li>
<li><code>becomeCandidateLocked</code> 没有调用 <code>resetElectionTimerLocked</code>（视频里没说）</li>
</ol>
<p>Raft 的细节是非常多的，即使我实现过很多次，也很容易因为粗心或者忘记细节造成问题。所以有错不可怕，关键是掌握科学的调试方法，可以参考 0x02. [附录2分布式调试]。</p>
<h1>实现关键点</h1>
<p>下面我罗列一些 PartA 实现的关键点，如果出错，可能会造成测试通不过：</p>
<ol>
<li>
<p>重置时钟本质上是<strong>认可对方权威</strong>，且承诺自己之后一段时间内不在发起选举。在代码中有两处：</p>
<ol>
<li>接收到心跳 RPC，并且认可其为 Leader</li>
<li>接受到选举 RPC，并且给出自己的选票</li>
</ol>
</li>
<li>
<p>在收到 RPC（回调函数）和收到 RPC 返回值时，第一件事就是要对齐 term。在 Raft 中，term 是一个非常关键的设定，只有在相同 term 内，一切对话才能展开。对齐 term 的逻辑就是：</p>
<ol>
<li>你 term 大，我无条件转 Follower</li>
<li>你 term 小，不理会你的请求</li>
</ol>
</li>
<li>
<p>role 字段在 figure 2 是没有列的，但是实现时是需要的，而且很核心。</p>
</li>
<li>
<p>所有访问全局变量的逻辑都要加锁。</p>
</li>
<li>
<p>我们在新进入一个 term 时，逻辑可以归结为：</p>
<ol>
<li>
<p>主动的：成为 Candidate，vote 给自己。具体来说，自己选举 timer 超时，增加 term ，转换为 <strong>Candidate</strong>。</p>
</li>
<li>
<p>被动的：成为 Follower，vote 设置空。具体来说，通过 RPC 发现对方 term 高，转换为 <strong>Follower</strong>，follow 对方 term。</p>
</li>
<li>
<p>换种说法，角色状态机的转换往往和 term 的变化存在着联系。两个特例 ：</p>
</li>
<li>
<ol>
<li>Candidate 当选 Leader 时，term 没有发生变化。</li>
<li>Candidate 在发现同 term 的 Leader 时，变成 Follower，term 也不变。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>写完之后，要对着状态机过一遍，主要就是看几个 become 函数的状态转换是否符合状态机，并在状态转换前做好了状态检查。</p>
</li>
</ol>
<h1>Q&amp;A</h1>
<ol>
<li>为什么 tick 的 interval（也就是 sleep） 也是 random 的？不是仅仅 election timeout 需要 random 的吗？
<ol>
<li>因为如果 tick 的 interval 不 random 可能会造成，即使 electionTimeout 是 random 的，但由于 tick 是固定间隔导致最后不同 Peer 检测到选举超时的间隔仍然是固定的。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>08. Raft PartB 日志同步</title>
    <url>//c5bca348.html</url>
    <content><![CDATA[<h1>实现要求</h1>
<p>在 PartA 的基础上，加入日志。即：</p>
<ol>
<li>在进行领导者选举时，要加入日志的比较。</li>
<li>领导者收到应用层发来日志后（<code>raft.Start</code>），要通过心跳同步给所有 Follower。</li>
<li>在收到多数 Follower 同步成功的请求后，Leader 要推进 <code>CommitIndex</code>，并让所有 Peer Apply。</li>
</ol>
<p>写完后在 <code>src/raft</code> 文件夹，使用 <code>go test -run PartB -race</code> 来测试代码逻辑是否正确、是否有数据竞态。</p>
<h1>实现要点</h1>
<ol>
<li>由于实现细节很多，在第一步要保证 <code>TestBasicAgreePartB()</code> 测试能够过。该测试用到的代码流程是，先实现 Start()，然后通过 AppendEntries RPC 发送给所有 Follower，最后在每个 Peer 上再将所有已提交日志<strong>按顺序</strong>发送到 applyCh 中。</li>
<li>实现领导者选举时的限制，具体可以参考<a href="https://raft.github.io/raft.pdf">论文中</a> 5.4.1 节。</li>
<li>一种常见的错误现象是，已经有 Leader 当选，但还是不断的有 Peer 发起选举。可以检查下选举超时和心跳间隔的配置是否正确、候选人当选 Leader 后是否立即发起心跳、发起选举时是否检查了自己是 Leader。</li>
<li>你可能会用一些逻辑来频繁的检测是否满足某种条件。建议不要实现为死循环，可以插入一些 Sleep：<code>time.Sleep(10 * time.Millisecond) </code>或者直接使用 Golang 的条件变量(附录1 sync.Cond)。</li>
<li>一定尽量有条理的组织你的代码，才能够使得出现 Bug 尽快定位，这方面我们之前章节详细讲过，可以参考：代码组织(02.Raft 代码总览) 和 PartA 中示例实现的一些组织章法。</li>
<li>如果你的某个测试过不了，可以参考 <code>config.go</code> 和 <code>test_test.go</code> 的测试逻辑，即 tester 如何制造混沌环境来对 Raft 提供的接口进行调用的。</li>
<li>所有关键的事件：角色变化、追加日志、应用日志等改变全局变量的各个关键环节，最好都打好日志。这样出现问题就能根据日志时间线来大致定位问题位置。</li>
<li>在测试的时候，可以先整体跑 <code>go test -run PartB</code> ，如果发现某个出现问题，再打开日志环境变量单独跑，如 <code>VERBOSE=0 go test -run TestRPCBytesPartB | tee out.txt </code>以避免多个测试用例日志混在一起。</li>
</ol>
<p>到此，你就可以自己写这部分代码然后做测试了，后面部分是实现部分，建议看到这里后，先自己实现一遍，然后跑测试。哪怕最终做不出来也先趟趟雷，才能带着问题去理解为什么要那么实现。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>06. Raft PartA 心跳逻辑</title>
    <url>//f3eb57ca.html</url>
    <content><![CDATA[<p>PartA 只需要实现不带日志的心跳。</p>
<p>需要说明的是：在论文中<strong>心跳</strong>（不带日志）和<strong>日志复制</strong>是用的一个 RPC，毕竟他们在逻辑上唯一的区别就是带不带日志。但在工程实践中，为了提升性能，有的 Raft 实现会将其进行分开。我们的课程里，为了保持简洁，也就实现到一块了。因为对于初学者来说，<strong>简洁比性能重要</strong>。</p>
<p>和选举逻辑相对，我们也分三个层次来实现 RPC <strong>发送方</strong>：</p>
<ol>
<li><strong>心跳 Loop</strong>：在当选 Leader 后起一个后台线程，等间隔的发送心跳/复制日志，称为 <code>replicationTicker</code></li>
<li><strong>单轮心跳</strong>：对除自己外的所有 Peer 发送一个心跳 RPC，称为 <code>startReplication</code></li>
<li><strong>单次 RPC</strong>：对某个 Peer 来发送心跳，并且处理 RPC 返回值，称为 <code>replicateToPeer</code></li>
</ol>
<p>当然，还有 RPC 接收方回调函数的逻辑。</p>
<p>心跳（日志复制）逻辑和选举逻辑实现层次一致、命名风格一致的好处在于，可以减少心智负担，方便调试和维护。</p>
<h1>心跳 Loop</h1>
<p>由于不用构造<strong>随机</strong>超时间隔，心跳 Loop 会比选举 Loop 简单很多：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicationTicker(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                ok := rf.startReplication(term)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                time.Sleep(replicateInterval)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与选举 Loop 不同的是，这里的 <code>startReplication</code> 有个返回值，主要是检测“上下文(05. Raft PartA 选举逻辑上下文检查)”是否还在（ <code>ContextLost</code> ）——一旦发现 Raft Peer 已经不是这个 term 的 Leader 了，就立即退出 Loop。</p>
<h1>单轮心跳</h1>
<p>和 Candidate 的选举逻辑类似，Leader 会给除自己外的所有其他 Peer 发送心跳。在发送前要检测“上下文(05. Raft PartA 选举逻辑上下文检查)是否还在，如果不在了，就直接返回 false ——告诉外层循环 <code>replicationTicker</code> 可以终止循环了。</p>
<p>因此 <code>startReplication</code> 的返回值含义为：是否成功的发起了一轮心跳。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                <span class="comment">// send heartbeat RPC and handle the reply</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Leader, term) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;Leader[T%d] -&gt; %s[T%d]&quot;</span>, term, rf.role, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        Term:     term,</span><br><span class="line">                        LeaderId: rf.me,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>单次 RPC</h1>
<p>在不关心日志时，心跳的返回值处理比较简单，只需要对齐下 term 就行。如果后续还要进行其他处理，则还要检查 context 是否丢失。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">        reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">        ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Lost or crashed&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>回调函数</h1>
<p>心跳接收方在收到心跳时，只要 Leader 的 term 不小于自己，就对其进行认可，变为 Follower，并重置选举时钟，承诺一段时间内不发起选举。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject log&quot;</span>, args.LeaderId)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reset the timer</span></span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>09. Raft PartB 结构调整</title>
    <url>//521bce04.html</url>
    <content><![CDATA[<p>从这一部分开始，我们的代码量开始陡然增大。为了避免所有代码都挤在一个 raft.go 文件中，我们将其按逻辑进行拆分：</p>
<ol>
<li>领导选举逻辑从<code>raft.go</code> 中拆出来，命名为 <code>raft_election.go</code></li>
<li>日志复制逻辑从 <code>rat.go</code> 中拆出来，命名为 <code>raft_replication.go</code></li>
<li>所有其他公用的逻辑剩下在 <code>raft.go</code> 中</li>
</ol>
<p>注：在 golang 中，同一个类的实现拆到多个文件中时，其他文件通常使用该类名作为前缀，在我们这，就是 <code>raft_XX.go</code></p>
<h1>选举拆分</h1>
<p>选举部分主要包括我们在 PartA 中提到的几部分：RPC 发送方的三个层次以及 RPC 接收方的回调函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functions in Candidate(RPC sender)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendRequestVote(server <span class="type">int</span>, args *RequestVoteArgs, reply *RequestVoteReply) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection(term <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> electionTicker()</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback in Peer(RPC receiver)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)</span><br></pre></td></tr></table></figure>
<p>此外，还有和他们关联的两个 RPC 的结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>和一些辅助函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// election timer checker and reset</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> resetElectionTimerLocked()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> isElectionTimeoutLocked() <span class="type">bool</span></span><br></pre></td></tr></table></figure>
<h1>复制拆分</h1>
<p>和领导者选举逻辑一样，也是主要包括 RPC 发送方的三个层次和 RPC 接收方的回调函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functions in Leader(RPC sender)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendAppendEntries(server <span class="type">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicationTicker(term <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback in Peer(RPC recevier)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)</span><br></pre></td></tr></table></figure>
<p>RPC 关联结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1>剩余逻辑</h1>
<p>剩下的逻辑，主要包括：</p>
<ol>
<li>一些公用的函数和配置：如状态机转换函数，<code>contextLost</code> 判断函数等等</li>
<li>对外提供的接口：如 <code>Start()</code>，<code>Make()</code> 等函数</li>
<li>暂时用不到的函数：如 PartC 中 <code>persist</code> 相关函数</li>
</ol>
<p>就留在 <code>raft.go</code> 文件中了。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>11. Raft PartB 选举日志比较</title>
    <url>//648216a0.html</url>
    <content><![CDATA[<p>在有了日志之后，在进行投票时，就需要进行日志比较了。</p>
<p>因为 Raft 算法是强 Leader 算法，因此会要求 Leader 一定要包含所有已经提交日志。因此，在进行选举时，我们确保只有具有比大多数 Peer 更新日志的候选人才能当选 Leader。</p>
<h1>日志新旧比较</h1>
<p>关于两个 Peer 所存日志谁更 up-to-date 的问题，<a href="https://raft.github.io/raft.pdf">论文</a>中是这样描述的：</p>
<blockquote>
<p>Raft determines which of two logs is more up-to-date by comparing the index and term of the last entries in the logs.</p>
<ol>
<li>If the logs have last entries with different terms, then the log with the later term is more up-to-date.</li>
<li>If the logs end with the same term, then whichever log is longer is more up-to-date</li>
</ol>
</blockquote>
<p>总结下，<strong>比较对象</strong>是最后一个 LogEntry，<strong>比较规则</strong>是：</p>
<ol>
<li>Term 高者更新</li>
<li>Term 同，Index 大者更新</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> isMoreUpToDateLocked(candidateIndex, candidateTerm <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        l := <span class="built_in">len</span>(rf.log)</span><br><span class="line">        lastTerm, lastIndex := rf.log[l<span class="number">-1</span>].Term, l<span class="number">-1</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;Compare last log, Me: [%d]T%d, Candidate: [%d]T%d&quot;</span>, lastIndex, lastTerm, candidateIndex, candidateTerm)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> lastTerm != candidateTerm &#123;</span><br><span class="line">                <span class="keyword">return</span> lastTerm &gt; candidateTerm</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastIndex &gt; candidateIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>增加日志比较</h1>
<p>选举这一块需要增加的逻辑比较简单，只需要：</p>
<ol>
<li>在发送 RPC 构造参数时增加上最后一条日志信息</li>
<li>在接收 RPC 投票前比较日志新旧</li>
</ol>
<p>根据论文图 2 补全 RPC 相关结构体字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// Your data here (PartA, PartB).</span></span><br><span class="line">        Term         <span class="type">int</span></span><br><span class="line">        CandidateId  <span class="type">int</span></span><br><span class="line">        LastLogIndex <span class="type">int</span></span><br><span class="line">        LastLogTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送方（Candidate），在发送 RPC 增加构造参数，带上 Candidate 最后一条日志的信息（index 和 term）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection(term <span class="type">int</span>) &#123;</span><br><span class="line">        votes := <span class="number">0</span></span><br><span class="line">        askVoteFromPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *RequestVoteArgs)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Candidate, term) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;Lost Candidate[T%d] to %s[T%d], abort RequestVote&quot;</span>, rf.role, term, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l := <span class="built_in">len</span>(rf.log)</span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        votes++</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                args := &amp;RequestVoteArgs&#123;</span><br><span class="line">                        Term:         rf.currentTerm,</span><br><span class="line">                        CandidateId:  rf.me,</span><br><span class="line">                        LastLogIndex: l<span class="number">-1</span>,</span><br><span class="line">                        LastLogTerm:  rf.log[l<span class="number">-1</span>].Term,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">go</span> askVoteFromPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收方（各个 Peer 的回调函数），在对齐 Term，检查完没有投过票之后，进一步比较最后一条日志，看谁的更新。如果本 Peer 比 Candidate 更新，则拒绝投票给 Candidate。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example RequestVote RPC handler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA, PartB).</span></span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject Vote, Higher term, T%d&gt;T%d&quot;</span>, args.CandidateId, rf.currentTerm, args.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check for votedFor</span></span><br><span class="line">        <span class="keyword">if</span> rf.votedFor != <span class="number">-1</span> &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject Voted, Already voted to S%d&quot;</span>, args.CandidateId, rf.votedFor)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check log, only grante vote when the candidates have more up-to-date log</span></span><br><span class="line">        <span class="keyword">if</span> rf.isMoreUpToDateLocked(args.LastLogIndex，args.LastLogTerm) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject Vote, S%d&#x27;s log less up-to-date&quot;</span>, args.CandidateId)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">        rf.votedFor = args.CandidateId</span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Vote granted&quot;</span>, args.CandidateId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>10. Raft PartB 日志复制</title>
    <url>//7c0fc3f6.html</url>
    <content><![CDATA[<p>PartB 需要定义日志格式，然后在 PartA 心跳逻辑的基础上，补全日志同步的逻辑。总体上来说，Leader 需要维护一个各个 Peer 的进度视图（<code>nextIndex</code> 和 <code>matchIndex</code> 数组）。其中 <code>nextIndex</code> 用于进行<strong>日志同步时</strong>的<strong>匹配点试探</strong>，<code>matchIndex</code> 用于<strong>日志同步成功后</strong>的<strong>匹配点记录</strong>。依据全局匹配点分布，我们可以计算出当前全局的 <code>commitIndex</code>，然后再通过之后轮次的日志复制 RPC 下发给各个 Follower。</p>
<p>每个 Follower 收到 <code>commitIndex</code> 之后，再去 apply 本地的已提交日志到状态机。但这个 <strong>apply 的流程</strong>，我们留到之后一章来专门做，本章就暂时留待 TODO 了。</p>
<p>因此，本章就只实现逻辑：<strong>匹配点的试探</strong>和<strong>匹配后的更新</strong>。</p>
<h1>结构体完善</h1>
<h2 id="AppendEntries-RPC-结构体">AppendEntries RPC 结构体</h2>
<p>根据 <code>ApplyMsg</code> 所需字段，来定义 <code>LogEntry</code> 。然后在此基础上，依照 <a href="https://raft.github.io/raft.pdf">Raft 论文</a>中的[图 2]来补全 RPC 涉及到的结构体：<code>AppendEntriesArgs</code> ，<code>AppendEntriesReply</code> 并不需要添加额外字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add log entries according to the ApplyMsg struct</span></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term         <span class="type">int</span></span><br><span class="line">        CommandValid <span class="type">bool</span></span><br><span class="line">        Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the fields about log: </span></span><br><span class="line"><span class="comment">// PrevLogIndex and PrevLogTerm is used to match the log prefix</span></span><br><span class="line"><span class="comment">// Entries is used to append when matched</span></span><br><span class="line"><span class="comment">// LeaderCommit tells the follower to update its own commitIndex</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term     <span class="type">int</span></span><br><span class="line">        LeaderId <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        PrevLogIndex <span class="type">int</span></span><br><span class="line">        PrevLogTerm  <span class="type">int</span></span><br><span class="line">        Entries      []LogEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term    <span class="type">int</span></span><br><span class="line">        Success <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Raft-结构体">Raft 结构体</h2>
<p>定义了 <code>LogEntry</code> 之后，完善下 raft struct 中相关字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log in Peer&#x27;s local</span></span><br><span class="line">log         []LogEntry</span><br><span class="line"></span><br><span class="line"><span class="comment">// only used when it is Leader,</span></span><br><span class="line"><span class="comment">// log view for each peer</span></span><br><span class="line">nextIndex  []<span class="type">int</span></span><br><span class="line">matchIndex []<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>则 <code>Make</code> 函数也要给上述字段进行初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;&#125;)</span><br><span class="line"></span><br><span class="line">        rf.matchIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">        rf.nextIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>RPC 接收方</h1>
<p>RPC 接收方，即 Leader 以外的其他 Peer。在考虑日志之后，要<strong>增加</strong>以下逻辑：</p>
<ol>
<li>如果 <code>prevLog</code> 不匹配，则返回 <code>Success = False</code></li>
<li>如果 <code>prevLog</code> 匹配，则将参数中的 <code>Entries</code> 追加到本地日志，返回 <code>Success = True</code>。</li>
</ol>
<p>所谓日志匹配：就是<strong>相同 Index 的地方，Term 相同</strong>；即 index 和 term 能唯一确定一条日志，这是因为，Raft 算法保证一个 Term 中最多有（也可能没有）一个 Leader，然后只有该 Leader 能确定日志顺序且同步日志。这样一来，Term 单调递增，每个 Term 只有一个 Leader，则该 Leader 能唯一确定该 Term 内的日志顺序。</p>
<p>此外，之前<strong>纯心跳逻辑</strong>（心跳逻辑和日志复制逻辑共用一个 RPC）只负责压制其他 Peer 发起选举，因此不用给 reply 返回信息。但此时，就需要用到 reply 了。</p>
<p><strong>注：之后代码块中，所有加粗代码为新增代码</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For debug</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, Receive log, Prev=[%d]T%d, Len()=%d&quot;</span>, args.LeaderId, args.PrevLogIndex, args.PrevLogTerm, <span class="built_in">len</span>(args.Entries))</span><br><span class="line">        <span class="comment">// replay initialized</span></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Higher term, T%d&lt;T%d&quot;</span>, args.LeaderId, args.Term, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if the previous log not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Follower log too short, Len:%d &lt;= Prev:%d&quot;</span>, args.LeaderId, <span class="built_in">len</span>(rf.log), args.PrevLogIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Prev log not match, [%d]: T%d != T%d&quot;</span>, args.LeaderId, args.PrevLogIndex, rf.log[args.PrevLogIndex].Term, args.PrevLogTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// append the leader logs to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;Follower append logs: (%d, %d]&quot;</span>, args.PrevLogIndex, args.PrevLogIndex+<span class="built_in">len</span>(args.Entries))</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle the args.LeaderCommit</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reset the election timer, promising not start election in some interval</span></span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好奇的你可能会问为什么不管 <code>args.LeaderCommit </code>，这部分自然要管，但我们将其留到之后 <code>applyLoop</code> 一节中（TODO：需要补充一个小节的链接）。这是因为，就逻辑的亲和性上来讲，<code>commitIndex</code> 是为最终的日志 apply 而服务的。但为了备忘，我们可以在代码注释中加一个 TODO 注释，这也是工程实践中常用的办法。</p>
<h1>RPC 发送方</h1>
<p>对于日志复制 RPC 发送方来说，需要增加两部分逻辑：</p>
<ol>
<li>每个 RPC 发送前的参数构造</li>
<li>每个 RPC 收到返回值后：
<ol>
<li>如果复制成功，则看看是否可以更新 Leader 的 commitIndex （也留到之后实现，TODO，补充小节链接）</li>
<li>如果复制失败，则需要将匹配点回退，继续试探。</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">                ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Lost or crashed&quot;</span>, peer)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// align the term</span></span><br><span class="line">                <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                        rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// probe the lower index if the prev log not matched</span></span><br><span class="line">                <span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">                        idx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                        term := rf.log[idx].Term</span><br><span class="line">                        <span class="keyword">for</span> idx &gt; <span class="number">0</span> &amp;&amp; rf.log[idx].Term == term &#123;</span><br><span class="line">                                idx--</span><br><span class="line">                        &#125;</span><br><span class="line">                        rf.nextIndex[peer] = idx + <span class="number">1</span></span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;Log not matched in %d, Update next=%d&quot;</span>, args.PrevLogIndex, rf.nextIndex[peer])</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// update the match/next index if log appended successfully</span></span><br><span class="line">                rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">                rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> need compute the new commitIndex here, </span></span><br><span class="line">                <span class="comment">// but we leave it to the other chapter</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Leader, term) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;Lost Leader[%d] to %s[T%d]&quot;</span>, term, rf.role, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        <span class="comment">// Don&#x27;t forget to update Leader&#x27;s matchIndex</span></span><br><span class="line">                        rf.matchIndex[peer] = <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">                        rf.nextIndex[peer] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                prevIdx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                prevTerm := rf.log[prevIdx].Term</span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        Term:         rf.currentTerm,</span><br><span class="line">                        LeaderId:     rf.me,</span><br><span class="line">                        PrevLogIndex: prevIdx,</span><br><span class="line">                        PrevLogTerm:  prevTerm,</span><br><span class="line">                        Entries:      rf.log[prevIdx+<span class="number">1</span>:],</span><br><span class="line">                        LeaderCommit: rf.commitIndex,</span><br><span class="line">                &#125;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Send log, Prev=[%d]T%d, Len()=%d&quot;</span>, peer, args.PrevLogIndex, args.PrevLogTerm, <span class="built_in">len</span>(args.Entries))</span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分的最终目的，就是要更新 <code>matchIndex</code>。进而依据所有 Peer 的 <code>matchIndex</code> 来算 <code>commitIndex</code> 。Leader 有了 <code>commitIndex</code> 之后，再将其下发给各个 Follower，指导其各自更新本地 <code>commitIndex</code> 进而 apply。</p>
<p>但细心的你可能会注意到一件事，<code>matchIndex</code> 和 <code>nextIndex</code>  是什么时候初始化的？所以，我们要继续补上这两个字段的初始化逻辑。本质上来说，这两个字段是各个 Peer 中日志进度在 Leader 中的一个<strong>视图</strong>（view）。Leader 正是依据此视图来决定给各个 Peer 发送多少日志。也是依据此视图，Leader 可以计算全局的 <code>commitIndex</code>。</p>
<p>因此，该视图只在 Leader 当选的 Term 中有用。故而，我们要在 Leader 一当选时，更新该视图，即 <code>becomeLeaderLocked</code> 中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeaderLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role != Candidate &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DError, <span class="string">&quot;Only Candidate can become Leader&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;Become Leader in T%d&quot;</span>, rf.currentTerm)</span><br><span class="line">        rf.role = Leader</span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                rf.nextIndex[peer] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">                rf.matchIndex[peer] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>12. Raft PartB 日志应用</title>
    <url>//84780d3f.html</url>
    <content><![CDATA[<p>本章我们要增加在代码组织(02.Raft 代码总览)一章中提到的三个工作流中的最后一个：日志应用工作流， <code>applyTicker</code>。</p>
<p>由于 Apply 只有在 <code>commitIndex</code> 变大的时候才会触发，因此我们可以使用 golang 中的条件变量 sync.Cond ，使用唤醒机制，只有在 <code>commitIndex</code> 增大后才唤醒 <code>applyTicker</code>。</p>
<h1>字段补全</h1>
<p>根据论文图 2 我们需要给 apply 逻辑补上两个字段：</p>
<ol>
<li><strong>commitIndex</strong>：全局日志提交进度</li>
<li><strong>lastApplied</strong>：本 Peer 日志 apply 进度</li>
</ol>
<p>由于我们想在实现时，使用 <code>sync.Cond</code> 唤醒 apply 的工作流，因此需要增加：<strong><code>applyCond</code></strong>。</p>
<p>最后，在我们 Raft 实现的设定中，apply 的过程，就是将 applyMsg 通过构造 Peer 时传进来的 channel 返回给应用层。因此还需要保存下这个 <strong>applyCh</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit index and last applied</span></span><br><span class="line">        commitIndex <span class="type">int</span></span><br><span class="line">        lastApplied <span class="type">int</span></span><br><span class="line">        applyCond   *sync.Cond</span><br><span class="line">        applyCh     <span class="keyword">chan</span> ApplyMsg</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加其初始化。<strong>applyCond</strong> 在初始化时，需要关联到一把锁上，这是<code> sync.Cond</code> 的使用要求，之后只有在该锁临界区内才可以进行 <code>Wait()</code> 和 <code>Signal()</code> 的调用。对于我们来说，这把锁自然就是全局的那把大锁：<code>rf.mu</code>。具体 <code>sync.Cond</code> 的工作原理可以参考并发编程一章的相关内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        rf.applyCh = applyCh</span><br><span class="line">        rf.commitIndex = <span class="number">0</span></span><br><span class="line">        rf.lastApplied = <span class="number">0</span></span><br><span class="line">        rf.applyCond = sync.NewCond(&amp;rf.mu)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line">        rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start ticker goroutine to start elections</span></span><br><span class="line">        <span class="keyword">go</span> rf.electionTicker()</span><br><span class="line">        <span class="keyword">go</span> rf.applyTicker()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Apply 工作流</h1>
<p>Apply 工作流在实现的时候，最重要的就是在给 applyCh 发送 ApplyMsg 时，不要在加锁的情况下进行。因为我们并不知道这个操作会耗时多久（即应用层多久会取走数据），因此不能让其在 apply 的时候持有锁。</p>
<p>于是，我们把 apply 分为三个阶段：</p>
<ol>
<li><strong>阶段一</strong>：构造所有待 apply 的 <code>ApplyMsg</code></li>
<li><strong>阶段二</strong>：遍历这些 msgs，进行 apply</li>
<li><strong>阶段三</strong>：更新 <code>lastApplied</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applyTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.applyCond.Wait()</span><br><span class="line"></span><br><span class="line">                entries := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// should start from rf.lastApplied+1 instead of rf.lastApplied</span></span><br><span class="line">                <span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">                        entries = <span class="built_in">append</span>(entries, rf.log[i])</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">                        rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                                CommandValid: entry.CommandValid,</span><br><span class="line">                                Command:      entry.Command,</span><br><span class="line">                                CommandIndex: rf.lastApplied + <span class="number">1</span> + i,</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Apply log for [%d, %d]&quot;</span>, rf.lastApplied+<span class="number">1</span>, rf.lastApplied+<span class="built_in">len</span>(entries))</span><br><span class="line">                rf.lastApplied += <span class="built_in">len</span>(entries)</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要我们保证全局就只有这一个 apply 的地方，那我们这样分成三个部分问题就不大。尤其是需要注意，当后面增加  snapshot  apply 的逻辑时，也要放到该函数里。</p>
<h1>Leader CommitIndex 更新</h1>
<p>在 Leader 给其他 Peer <code>AppendEntries</code> 成功后，会更新 <code>rf.matchIndex</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the commmit index if log appended successfully</span></span><br><span class="line">        rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">        rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span> <span class="comment">// important: must update</span></span><br><span class="line">        majorityMatched := rf.getMajorityIndexLocked()</span><br><span class="line">        <span class="keyword">if</span> majorityMatched &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Leader update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, majorityMatched)</span><br><span class="line">                rf.commitIndex = majorityMatched</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次更新 <code>rf.matchIndex</code> 后，依据此全局匹配点视图，我们可以算出多数 Peer 的匹配点，进而更新 Leader 的 <code>CommitIndex</code>。我们可以使用<strong>排序后找中位数</strong>的方法来计算。</p>
<p>这里需要说明一下，也是视频中没有说明白的地方，就是排序之后是匹配点<strong>从小到大</strong>，因此需要找左边的那个（如果 peers 是偶数的话）中位数，才是多数派的匹配点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getMajorityIndexLocked() <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(spw): may could be avoid copying</span></span><br><span class="line">        tmpIndexes := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.matchIndex))</span><br><span class="line">        <span class="built_in">copy</span>(tmpIndexes, rf.matchIndex)</span><br><span class="line">        sort.Ints(sort.IntSlice(tmpIndexes))</span><br><span class="line">        majorityIdx := (<span class="built_in">len</span>(tmpIndexes) - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;Match index after sort: %v, majority[%d]=%d&quot;</span>, tmpIndexes, majorityIdx, tmpIndexes[majorityIdx])</span><br><span class="line">        <span class="keyword">return</span> tmpIndexes[majorityIdx] <span class="comment">// min -&gt; max</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于排序会改变原数组，因此要把 matchIndex 复制一份再进行排序，</p>
<p>如果 <code>commitIndex</code> 更新后，则唤醒 apply 工作流，提醒可以 apply 新的日志到本地了。</p>
<h1>Follower CommitIndex 更新</h1>
<p>在 Leader CommitIndex 更新后，会通过下一次的 <code>AppendEntries</code> 的 RPC 参数发送给每个 Follower。则首先，要根据论文图 2，在 <code>AppendEntriesArgs</code> 中增加 <code>LeaderCommit</code> 参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term     <span class="type">int</span></span><br><span class="line">        LeaderId <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        PrevLogIndex <span class="type">int</span></span><br><span class="line">        PrevLogTerm  <span class="type">int</span></span><br><span class="line">        Entries      []LogEntry</span><br><span class="line"></span><br><span class="line">        LeaderCommit <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Follower 通过 AppendEntries 的回调函数收到 Leader 发来的 <code>LeaderCommit</code>，来更新本地的 <code>CommitIndex</code>，进而驱动 Apply 工作流开始干活。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, Receive log, Prev=[%d]T%d, Len()=%d&quot;</span>, args.LeaderId, args.PrevLogIndex, args.PrevLogTerm, <span class="built_in">len</span>(args.Entries))</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Higher term, T%d&lt;T%d&quot;</span>, args.LeaderId, args.Term, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if the previous log not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Follower log too short, Len:%d &lt;= Prev:%d&quot;</span>, args.LeaderId, <span class="built_in">len</span>(rf.log), args.PrevLogIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Prev log not match, [%d]: T%d != T%d&quot;</span>, args.LeaderId, args.PrevLogIndex, rf.log[args.PrevLogIndex].Term, args.PrevLogTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// append the leader logs to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;Follower append logs: (%d, %d]&quot;</span>, args.PrevLogIndex, args.PrevLogIndex+<span class="built_in">len</span>(args.Entries))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the commit index if needed and indicate the apply loop to apply</span></span><br><span class="line">        <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Follower update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, args.LeaderCommit)</span><br><span class="line">                rf.commitIndex = args.LeaderCommit</span><br><span class="line">                <span class="keyword">if</span> rf.commitIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                    rf.commitIndex = <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reset the election timer, promising not start election in some interval</span></span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 Peer 收到 Leader 发来的日志同步请求处理逻辑中，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">            rf.becomeFollowerLocked(args.Term)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>大家可能有个问题，对于大于的情况，容易理解，论文中就这么写的。为什么相同任期也要变为 Follower？</p>
<p>对于相同任期来说，可以分情况考虑：</p>
<ol>
<li>首先他不可能是 leader，因为一个任期最多只会选出一个 leader</li>
<li>如果他是 Candidate，收到 Leader 的日志同步请求，得变 Follower</li>
<li>如果本来就是 Follower 就无所谓了</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>14. Raft PartC 状态持久化</title>
    <url>//2924ee3f.html</url>
    <content><![CDATA[<h1>实现要求</h1>
<p>PartA 和 PartB 基本实现了<strong>不宕机</strong>情况下的领导者选举、日志同步和日志应用逻辑。但是在当某个 Peer 异常重启后，是不能正常重新加入集群的。为此，需要将 Raft 的关键信息定时持久化，重启后加载，以保证正常加入集群。</p>
<p>至于哪些状态需要持久化，论文图 2 都有标记。这些需要持久化的属性集中任何一个属性发生变化，都需要进行持久化，因为 Peer 任意时刻都有可能宕机。在本课程中，我们不会真将状态持久化到硬盘上，而是使用测试框架中的 <code>persistor.go</code> 中的 <code>Persister</code> 类对数据进行“持久化”，主要涉及两个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Persister)</span></span> ReadRaftState() []<span class="type">byte</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Persister)</span></span> Save(raftstate []<span class="type">byte</span>, snapshot []<span class="type">byte</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReadRaftState</code> 是反序列化接口，可以认为是从磁盘上读出一个字节数组；<code>Save</code> 是序列化接口，负责将字节数组形式的快照（PartD 才用）和 raft 状态写入磁盘。</p>
<p>写完后在 <code>src/raft</code> 文件夹，使用 <code>go test -run PartC -race</code> 来测试代码逻辑是否正确、是否有数据竞态。</p>
<h1>实现要点</h1>
<p>从上面的接口可以看出，你还需要一个序列化工具，将 Raft 状态序列化为字节数组。可以使用 tester 中提供的 <code>labgob</code> 包，这是一个很简易的序列化和反序列化类。注释中有给一些简单的例子来说明 labgob 如何用。</p>
<p>序列化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.xxx)</span><br><span class="line">e.Encode(rf.yyy)</span><br><span class="line">raftstate := w.Bytes()</span><br><span class="line">rf.persister.Save(raftstate, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>反序列化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"><span class="keyword">var</span> xxx</span><br><span class="line"><span class="keyword">var</span> yyy</span><br><span class="line"><span class="keyword">if</span> d.Decode(&amp;xxx) != <span class="literal">nil</span> ||</span><br><span class="line">    d.Decode(&amp;yyy) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//   error...</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   rf.xxx = xxx</span><br><span class="line">   rf.yyy = yyy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，核心在于利用 labgob 的接口，来实现 ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>两个函数。并且在合适的地方调用 <code>persist</code> 持久化 raft 状态。</p>
<p>以下是一些实现注意点：</p>
<ol>
<li><code>labgob</code> 序列化的 struct 中的所有字段必须都要首字母大写。</li>
<li><code>Persister.Save</code> 的第二个 <code>Snapshot</code> 参数在 PartC 中传 nil 就可以。</li>
<li>每次需要持久化的字段发生改变时，都记得调用 <code>rf.persist()</code> 。</li>
<li>PartC 可能会让你 PartA 和 PartB 中有些实现的不好的地方暴露出来，毕竟前两个测试也不能面面俱到。</li>
<li>PartC 会加大日志的写入量。而在日志量大且有的 Peer 宕机很久时，在日志同步时如果只是一个 entry 一个 entry 的后退，可能会导致在规定时间内完不成测试。一个 term 一个 term 的退可能也不够，下面依据<a href="https://raft.github.io/raft.pdf">论文</a>第七页底到第八页头的叙述，给出了一种优化方法。</li>
</ol>
<p>日志同步时“试探阶段”的优化。主要思路是将 Follower 的一些日志信息在 <code>AppendEntriesReply</code> 时返回给 Leader。Leader 根据这些信息来快速决定下次的 <code>nextIndex</code>。假设当 Follower 因 prevLog 冲突而拒绝 Leader 时，有如下信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">XTerm:  空，或者 Follower 与 Leader PrevLog 冲突 entry 所存 term</span><br><span class="line">XIndex: 空，或者 XTerm 的第一个 entry 的 index</span><br><span class="line">XLen:   Follower 日志长度</span><br></pre></td></tr></table></figure>
<p>则 Leader 的逻辑可以为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Case <span class="number">1</span>: Follower 的 Log 太短了:（迅速退到和 Follower 同长度）</span><br><span class="line">    nextIndex = XLen</span><br><span class="line">Case <span class="number">2</span>: Leader 没有 XTerm:（以 Follower 为准迅速回退跳过该 term 所有日志）</span><br><span class="line">    nextIndex = XIndex</span><br><span class="line">Case <span class="number">3</span>: Leader 存在 XTerm:（以 Leader 为准，迅速回退跳过该 term 所有日志）</span><br><span class="line">    nextIndex = Leader 在 XTerm 第一个 entry 的 index</span><br></pre></td></tr></table></figure>
<p>因此，这一节的主要考察点除了正确的持久化，最重要的就是对日志同步性能的优化。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>15. Raft PartC 实现和优化</title>
    <url>//ca0a1990.html</url>
    <content><![CDATA[<p>PartC 最主要的逻辑包括两部分：</p>
<ol>
<li>实现 Raft 的序列化和反序列化函数</li>
<li>将上述函数插入到代码流程中合适位置</li>
</ol>
<p>但由于测试时加入了不同 Peer 的宕机重启，对我们之前的选主逻辑和复制逻辑的<strong>正确性</strong>和<strong>性能</strong>又提出了更高的要求。也就是说，同样的代码，即使能过 PartB 的测试，也不一定能过 PartC 的测试。</p>
<p>因此，我们本节的大部分时间，反而会花在于对之前代码逻辑的<strong>性能提升</strong>和<strong>查漏补缺</strong>上。</p>
<h1>逻辑实现</h1>
<h2 id="序列化和反序列化">序列化和反序列化</h2>
<p>为了使代码模块清晰，我们将这部分也单独拆出一个文件，起名为 <code>raft_persistence.go</code>，主要包括对关键字段的序列化和反序列化两个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persistLocked() &#123;</span><br><span class="line">        w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">        e := labgob.NewEncoder(w)</span><br><span class="line">        e.Encode(rf.currentTerm)</span><br><span class="line">        e.Encode(rf.votedFor)</span><br><span class="line">        e.Encode(rf.log)</span><br><span class="line">        raftstate := w.Bytes()</span><br><span class="line">        <span class="comment">// leave the second parameter nil, will use it in PartD</span></span><br><span class="line">        rf.persister.Save(raftstate, <span class="literal">nil</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore previously persisted state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> currentTerm <span class="type">int</span></span><br><span class="line">        <span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line">        <span class="keyword">var</span> log []LogEntry</span><br><span class="line"></span><br><span class="line">        r := bytes.NewBuffer(data)</span><br><span class="line">        d := labgob.NewDecoder(r)</span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;currentTerm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DPersist, <span class="string">&quot;Read currentTerm error: %v&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.currentTerm = currentTerm</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;votedFor); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DPersist, <span class="string">&quot;Read votedFor error: %v&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.votedFor = votedFor</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;log); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DPersist, <span class="string">&quot;Read log error: %v&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.log = log</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DPersist, <span class="string">&quot;Read Persist %v&quot;</span>, rf.stateString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据[图 2]我们可以看出，在 Raft 结构体内，需要持久化的主要有三个字段：<code>currentTerm</code>，<code>votedFor</code> 和 <code>log</code>。这三者需要持久化的大致原因如下：</p>
<ol>
<li><strong><code>currentTerm</code></strong>：重启后一定要知道自己之前任期到了哪里，因为任期是状态机中一切正确行为的基础。</li>
<li><strong><code>votedFor</code></strong>：如果我们在某个任期已经投过票了，重启之后显然不能再投票，否则就会一票多投，是作弊了。</li>
<li><strong><code>log</code></strong>：日志是自然要持久化的。否则只要集群内的多数机器重启几次，已经提交的日志也会被丢失。</li>
</ol>
<p>另外， <code>persist</code> 函数加上 <code>-Locked</code> 后缀的原因在于，上面三个字段都是全局变量，因此需要在临界区调用，不然会出现数据竞态（data race）。而 <code>readPersist</code> 不加 <code>-Locked</code> 的原因在于，它只有在构造 Raft Peer 的时候才会被调用，而此时在一个 Raft struct 内部是不会有多线程的，因此不需要担心并发问题。</p>
<h2 id="函数调用">函数调用</h2>
<h3 id="readPersist">readPersist</h3>
<p><code>readPersist</code> 函数只有在重启加载时才需要调用，也就是在构造 Raft 实例时。但需要注意的是，一定要在所有字段初始化完成后，再调用该函数。</p>
<p>如果是先调用 <code>readPersist</code> 再去初始化，就会把 <code>readPersist</code> 读出来的值给覆盖掉。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        rf := &amp;Raft&#123;&#125;</span><br><span class="line">        rf.peers = peers</span><br><span class="line">        rf.persister = persister</span><br><span class="line">        rf.me = me</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  initialization code </span></span><br><span class="line">        rf.role = Follower</span><br><span class="line">        rf.currentTerm = <span class="number">1</span> <span class="comment">// leave 0 to invalid</span></span><br><span class="line">        rf.votedFor = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// a dummy entry to aovid lots of corner checks</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;Term: InvalidTerm&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize the leader&#x27;s view slice</span></span><br><span class="line">        rf.nextIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">        rf.matchIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize the fields used for apply</span></span><br><span class="line">        rf.applyCh = applyCh</span><br><span class="line">        rf.applyCond = sync.NewCond(&amp;rf.mu)</span><br><span class="line">        rf.commitIndex = <span class="number">0</span></span><br><span class="line">        rf.lastApplied = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line">        rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start election ticker and apply ticker</span></span><br><span class="line">        <span class="keyword">go</span> rf.electionTicker()</span><br><span class="line">        <span class="keyword">go</span> rf.applicationTicker()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="persistLocked">persistLocked</h3>
<p><code>readPersist</code> 函数的调用整体较为简单，<code>persistLocked</code> 函数相对较复杂，很容易遗漏一些地方。一个简单的办法就是在代码中搜索出三个成员变量：<code>currentTerm</code>，<code>votedFor</code> 和 <code>log</code> 被赋值修改的所有地方，然后逐个修改在其后增加 <code>persistLocked</code> 语句即可。</p>
<p>一共有五处需要增加。</p>
<p><code>raft.go</code> 中三处：</p>
<p>在 Leader 接受应用层命令的接口 <code>Start</code> 函数中，要将 <code>command</code> 包裹为日志，然后追加到本地日志中，即会修改 <code>rf.log </code>，因此要调用 <code>persist</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;</span><br><span class="line">                CommandValid: <span class="literal">true</span>,</span><br><span class="line">                Command:      command,</span><br><span class="line">                Term:         rf.currentTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span>, rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在状态机相关函数中，<code>becomeFollower</code> 和 <code>becomeCandidate</code> 都有可能会涉及 <code>term</code> 和 <code>votedFor</code> 的更新，因此要加：</p>
<ol>
<li><code>becomeFollower</code>：注意该函数中，term 是有可能不变的。在 term 不变时，并不需要 <code>persist</code>——因为 term 不变，<code>votedFor</code> 一定不会被重新赋值。</li>
<li><code>becomeCandidate</code>：变 Candidate，一定会自增 term，同时投自己的票。因此肯需要调用 <code>persist</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeFollowerLocked(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> term &lt; rf.currentTerm &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.role = Follower</span><br><span class="line"></span><br><span class="line">        shouldPersist := term != rf.currentTerm</span><br><span class="line">        <span class="keyword">if</span> term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.votedFor = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.currentTerm = term</span><br><span class="line">        <span class="keyword">if</span> shouldPersist &#123;</span><br><span class="line">                rf.persistLocked()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeCandidateLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role == Leader &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.currentTerm++</span><br><span class="line">        rf.role = Candidate</span><br><span class="line">        rf.votedFor = rf.me</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>raft_election.go</code> 中一处：</p>
<p>在要票的回调函数 <code>RequestVote</code> 中，如果 Peer 投出票，则会修改 <code>votedFor</code>，因此需要调用 <code>persist</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA, PartB).</span></span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check for votedFor</span></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if candidate&#x27;s last log is more up to date</span></span><br><span class="line">        <span class="keyword">if</span> rf.isMoreUpToDateLocked(args.LastLogIndex, args.LastLogTerm) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">        rf.votedFor = args.CandidateId</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>raft_replication.go</code> 中有一处：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// will be explained in the next section</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                rf.resetElectionTimerLocked()</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if prevLog not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append the leader log entries to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hanle LeaderCommit</span></span><br><span class="line">        <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">                rf.commitIndex = args.LeaderCommit</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>优化及修错</h1>
<p>我们知道 Leader 在给 Follower 同步日志时，由于采用乐观+回撤(01.日志同步)的做法，会经历一个<strong>匹配探测期</strong>，在 PartA、PartB 的测试中，并没有在这一点上为难我们。但在 PartC 中，由于加大了日志量、引入了各种随机重启，导致这个匹配探测期耗时可能会非常长。如果我们实现的效率很低，不仅会导致在规定的时间内提交不了应用层想要提交的日志，还会引发之前实现没有注意的问题。让我们一个个来说。</p>
<h2 id="日志回溯优化">日志回溯优化</h2>
<p>由于 Leader 在向 Follower 同步日志时，采用的是乐观+回撤(01.日志同步)的做法，而每次回撤后都需要下一个 RPC 才能发给 Follower，而我们的 <code>AppendEntries</code> RPC 是周期性的，也就是说每次回撤都需要一个  <code>replicateInterval</code> 。</p>
<p>如果回撤的算法不够好，在某些情况下，就会导致匹配探测期时间特别长。测试证明，在 Leader <strong>只基于自己的日志</strong>进行回撤的情况下，一次不管是回退一个 index 还是回退一个 term，效果都不够好。那还能怎样优化呢？</p>
<p><strong>让 Follower 给点信息</strong>——告诉 Leader 自己日志大致到哪里了！</p>
<p>于是我们给  AppendEntriesReply 增加两个额外的字段，以携带一些 Follower 和 Leader 冲突日志的信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term    <span class="type">int</span></span><br><span class="line">        Success <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">        ConfilictIndex <span class="type">int</span></span><br><span class="line">        ConfilictTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower 端大概算法如下：</p>
<ol>
<li>如果 Follower 日志过短，则<code>ConfilictTerm</code> 置空， <code>ConfilictIndex = len(rf.log)</code>。</li>
<li>否则，将 <code>ConfilictTerm</code> 设置为 Follower 在 <code>Leader.PrevLogIndex</code> 处日志的 term；<code>ConfilictIndex</code> 设置为 <code>ConfilictTerm</code> 的第一条日志。</li>
</ol>
<p>第一条做法的目的在于，如果 Follower 日志过短，可以提示 Leader 迅速回退到 Follower 日志的末尾，而不用傻傻的一个个 index 或者 term 往前试探。</p>
<p>第二条的目的在于，如果 Follower 存在 <code>Leader.PrevLog</code> ，但不匹配，则将对应 term 的日志全部跳过。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- rf.AppendEntries in raft_replication.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return failure if prevLog not matched</span></span><br><span class="line"><span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">        reply.ConfilictIndex = <span class="built_in">len</span>(rf.log)</span><br><span class="line">        reply.ConfilictTerm = InvalidTerm</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">        reply.ConfilictTerm = rf.log[args.PrevLogIndex].Term</span><br><span class="line">        reply.ConfilictIndex = rf.firstIndexFor(reply.ConfilictTerm)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Leader 端使用上面两个新增字段的算法如下：</p>
<ol>
<li>如果 <code>ConfilictTerm</code> 为空，说明 Follower 日志太短，直接将 <code>nextIndex</code> 赋值为 <code>ConfilictIndex</code> 迅速回退到 Follower 日志末尾**。**</li>
<li>否则，以 Leader 日志为准，跳过 <code>ConfilictTerm</code> 的所有日志；如果发现 Leader 日志中不存在 <code>ConfilictTerm</code> 的任何日志，则以 Follower 为准跳过 <code>ConflictTerm</code>，即使用 <code>ConfilictIndex</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- rf.startReplication.replicateToPeer in raft_replication.go</span></span><br><span class="line"><span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">        prevNext := rf.nextIndex[peer]</span><br><span class="line">        <span class="keyword">if</span> reply.ConfilictTerm == InvalidTerm &#123;</span><br><span class="line">                rf.nextIndex[peer] = reply.ConfilictIndex</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                firstTermIndex := rf.firstIndexFor(reply.ConfilictTerm)</span><br><span class="line">                <span class="keyword">if</span> firstTermIndex != InvalidIndex &#123;</span><br><span class="line">                        rf.nextIndex[peer] = firstTermIndex + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        rf.nextIndex[peer] = reply.ConfilictIndex</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// avoid the late reply move the nextIndex forward again</span></span><br><span class="line">        rf.nextIndex[peer] = MinInt(prevNext, rf.nextIndex[peer])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于我们如何表示空 term 和空 index 呢？</p>
<ol>
<li><strong>空 term</strong>：可以在 make Raft 时让 term 从 1 开始，则 0 就空了出来，可以用来表示空 term，在代码里叫 <code>InvalidTerm</code></li>
<li><strong>空 index</strong>：还记得我们在 rf.log 起始加了一个空 entry 吗？由于这个小技巧，我们的有效日志也是永远从 1 开始，0 就可以用来标识空 index，代码中叫 <code>InvalidIndex</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- in raft.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        InvalidIndex <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">        InvalidTerm  <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为了让代码看着更易懂，我们封装了一个在日志数组中找指定 term 第一条日志的函数<code>rf.firstLogFor</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- in raft.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> firstLogFor(term <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, entry := <span class="keyword">range</span> rf.log &#123;</span><br><span class="line">                <span class="keyword">if</span> entry.Term == term &#123;</span><br><span class="line">                        <span class="keyword">return</span> i</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> entry.Term &gt; term &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> InvalidIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于从前往后，日志的 term 是一段段的单调递增的，则从前往后找，找到第一个满足 term 的日志，就可以返回。如果相关 term 不存在，则返回 <code>InvalidIndex</code>。</p>
<h2 id="隐藏-bug-修复">隐藏 bug 修复</h2>
<p>我们在 Raft PartB 最后一章(13逻辑自查)提到过，有些问题在 PartA、PartB 测试中暴露不出来，但在 PartC 中就会暴露出来。这是因为 PartC 中的测试加大了日志量，加入了随机宕机重启，使得整个环境更加严苛，因此对 Raft 实现的正确性要求更高。这种错误，主要有两处。而这两处错误，也是因为上文提到的 PartC 测试特意引入的 Leader 日志同步时很长的<strong>匹配探测</strong>期所带来的。</p>
<p>其一，在收到 AppendEntries RPC 时，无论 Follower 接受还是拒绝日志，只要认可对方是 Leader 就要<strong>重置时钟</strong>。但在我们之前的实现，只有接受日志才会重置时钟。这是不对的，如果 Leader 和 Follower 匹配日志所花时间特别长，Follower 一直不重置选举时钟，就有可能错误的选举超时触发选举。</p>
<p>这里我们可以用一个 defer 函数来在合适位置之后来无论如何都要重置时钟：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- in raft_replication.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// After we align the term, we accept the args.LeaderId as</span></span><br><span class="line">        <span class="comment">// Leader, then we must reset election timer wheter we</span></span><br><span class="line">        <span class="comment">// accept the log or not</span></span><br><span class="line">        <span class="keyword">defer</span> rf.resetElectionTimerLocked()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if prevLog not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                <span class="comment">// if we truncate log here, should persist</span></span><br><span class="line">                rf.log = rf.log[<span class="number">0</span>:args.PrevLogIndex] </span><br><span class="line">                rf.persistLocked()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append the leader log entries to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hanle LeaderCommit</span></span><br><span class="line">        <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">                rf.commitIndex = args.LeaderCommit</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其二，匹配探测期比较长时，会有多个探测的 RPC，如果 RPC 结果乱序回来：一个先发出去的探测 RPC 后回来了，其中所携带的 <code>ConfilictTerm</code> 和 <code>ConfilictIndex</code> 就有可能造成 <code>rf.next</code> 的“反复横跳”。为此，我们可以强制 <code>rf.next</code> 单调递减：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- rf.startReplication in raft_replication.go</span></span><br><span class="line"><span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">        prevIndex := rf.nextIndex[peer]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// some code omitted....</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// avoid the late reply move the nextIndex forward again</span></span><br><span class="line">        <span class="keyword">if</span> rf.nextIndex[peer] &gt; prevIndex &#123;</span><br><span class="line">                rf.nextIndex[peer] = prevIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>13. Raft PartB 调试和小结</title>
    <url>//c2b809ab.html</url>
    <content><![CDATA[<p>经过调试，我们有几个地方没有实现对：日志同步的 reply 处理前没有检查 context、Start 没有实现、AppendEntries 日志判断。</p>
<h2 id="Context-检查">Context 检查</h2>
<p>需要 Context 检查的主要有四个地方：</p>
<ol>
<li>startReplication 前，检查自己仍然是给定 term 的 Leader</li>
<li>replicateToPeer 处理 reply 时，检查自己仍然是给定 term 的 Leader</li>
<li>startElection 前，检查自己仍然是给定 term 的 Candidate</li>
<li>askVoteFromPeer 处理 reply 时，检查自己仍然是给定 term 的 Candidate</li>
</ol>
<p>由于我们 replication 和 election 实现的对称性，可以发现前两个和后两个是对称的，因此很好记忆。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">        reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">        ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Lost or crashed&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check context lost</span></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Leader, term) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Context Lost, T%d:Leader-&gt;T%d:%s&quot;</span>, peer, term, rf.currentTerm, rf.role)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hanle the reply</span></span><br><span class="line">        <span class="comment">// probe the lower index if the prevLog not matched</span></span><br><span class="line">        <span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">                <span class="comment">// go back a term</span></span><br><span class="line">                idx, term := args.PrevLogIndex, args.PrevLogTerm</span><br><span class="line">                <span class="keyword">for</span> idx &gt; <span class="number">0</span> &amp;&amp; rf.log[idx].Term == term &#123;</span><br><span class="line">                        idx--</span><br><span class="line">                &#125;</span><br><span class="line">                rf.nextIndex[peer] = idx + <span class="number">1</span></span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Not matched at %d, try next=%d&quot;</span>, peer, args.PrevLogIndex, rf.nextIndex[peer])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update match/next index if log appended successfully</span></span><br><span class="line">        rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries) <span class="comment">// important</span></span><br><span class="line">        rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the commitIndex</span></span><br><span class="line">        majorityMatched := rf.getMajorityIndexLocked()</span><br><span class="line">        <span class="keyword">if</span> majorityMatched &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Leader update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, majorityMatched)</span><br><span class="line">                rf.commitIndex = majorityMatched</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Start-实现">Start 实现</h2>
<p>只有正确实现了 Start，tester 才能通过 Start 给 Leader 本地追加日志。进而通过 Leader 的 AppendEntries RPC 将日志分发给所有 Follower，然后在发现大多数 Peer 在本地追加该日志之后，指示每个 Peer Apply 该日志。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;</span><br><span class="line">                CommandValid: <span class="literal">true</span>,</span><br><span class="line">                Command:      command,</span><br><span class="line">                Term:         rf.currentTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;Leader accept log [%d]T%d&quot;</span>, <span class="built_in">len</span>(rf.log)<span class="number">-1</span>, rf.currentTerm)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span>, rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现中有两点需要注意：</p>
<ol>
<li>Append  日志前一点要先检查自己是否仍然为 Leader：只有 Leader 才能直接 Append 日志到本地，也即整个 Raft Group <strong>只有一个外界数据接收点</strong>——那就是 Leader；不遵循此原则，会出现日志冲突。</li>
<li>构造 LogEntry 的时候不要忘记填 Term 字段：在选领导者的时候会通过比较最后一条日志的 term 来确定谁更 up-to-date，不设置 term，会使得该比较出问题，导致不具有所有提交日志的 Candidate 当选 Leader。</li>
</ol>
<h2 id="AppendEntries-边界检查">AppendEntries 边界检查</h2>
<p>在判断  <code>args.PrevLogIndex &gt;= len(rf.log)</code> 的时候忘记了等号**。**</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject log, Higher term, T%d&lt;T%d&quot;</span>, args.LeaderId, args.Term, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if prevLog not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject log, Follower log too short, Len:%d &lt; Prev:%d&quot;</span>, args.LeaderId, <span class="built_in">len</span>(rf.log), args.PrevLogIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject log, Prev log not match, [%d]: T%d != T%d&quot;</span>, args.LeaderId, args.PrevLogIndex, rf.log[args.PrevLogIndex].Term, args.PrevLogTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append the leader log entries to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;Follower accept logs: (%d, %d]&quot;</span>, args.PrevLogIndex, args.PrevLogIndex+<span class="built_in">len</span>(args.Entries))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hanle LeaderCommit</span></span><br><span class="line">        <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Follower update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, args.LeaderCommit)</span><br><span class="line">                rf.commitIndex = args.LeaderCommit</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是和测试速度相关的 replicateInterval 参数设置，设的越小，测试通过越快。但是不能太小，因为测试框架会卡下界，我试了下，这个下界应该是 60 ms。因此我们将其设置为 70 ms：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        electionTimeoutMin time.Duration = <span class="number">250</span> * time.Millisecond</span><br><span class="line">        electionTimeoutMax time.Duration = <span class="number">400</span> * time.Millisecond</span><br><span class="line"></span><br><span class="line">        replicateInterval time.Duration = <span class="number">70</span> * time.Millisecond</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1>逻辑自查</h1>
<p>在我们进行调试之前，可以先看一个我之前总结的 Bug 检查列表，逐一进行下对照，看是否遗漏了某些实现。</p>
<ol>
<li>Start 函数是否实现。</li>
<li>注意特殊更新 <strong>leader 自己</strong>对应的 <code>nextIndex</code> 和 <code>matchIndex</code>
<ol>
<li>初始化时需要设定 <code>matchIndex = len(rf.log) - 1</code>，当然，由于每次 RPC 时设定了，这里也可以不管。</li>
<li>发 RPC 阶段可以跳过，但<strong>也要</strong>更新 <code>matchIndex = len(rf.log) - 1</code>，因为可能 rf.log 可能由于 Start 的调用而改变了。</li>
</ol>
</li>
<li>依据 <code>matchIndex</code> 计算多数日志进度问题：
<ol>
<li>在 Sort 之后，顺序是从小到大的，因此在计算 CommitIndex 时要取中位数偏左边那个数</li>
<li><code>tmpIndexes := rf.matchIndex[:] </code>不会复制 Slice 底层数组。得新建一个 Slice，然后使用 copy 函数才能避免 sort 对 matchIndex 的影响。</li>
</ol>
</li>
<li>选举时钟 Election Timer 重置问题
<ol>
<li>**（PartB 可过，PartC 过不了）**日志不匹配时，也要 reset timer</li>
</ol>
</li>
<li>在 startReplication 函数内只使用传入的参数 Term：leaderTerm
<ol>
<li>每次加锁后，都要先校验 contextLost，即是否为 Leader，是否 <code>rf.currentTerm == leaderTerm</code> 。</li>
<li>校验后，统一使用 leaderTerm，表明 term 没有 change 过。</li>
</ol>
</li>
<li>别忘了在 AppendEntriesArgs 中设置 leaderCommit</li>
<li>别忘了在 RequestVoteArgs 中设置 LastLogIndex 和 LastLogTerm</li>
<li>More up-to-date 比较的时候 term 和 index 参数别传反了</li>
<li>Leader 和 Follower 都要在合适的时候 apply 日志。即在更新 commitIndex 时， 设置 <code>applyCond.Signal</code>，来唤醒 <code>applicationTicker</code></li>
<li>上一个 AppendEntries 的处理结果还没回来，下一个就已经发出去了，导致同样的 prevTerm/prevIndex 的 RPC 发了多次。如果 Follower 接到 RPC 就删除日志，甚至会导致两次返回去 conflict index 和 term 不一样</li>
<li>（<strong>PartB 可过，PartC 过不了</strong>）AppendEntries 的试探阶段，reply 会乱序回来。这可能会导致，本来已经找到匹配点了，但是此时回来了一个延迟到达之前非匹配的点失败回复。这种请求应该通过合理方式拒掉这种延迟回复。比如比对 <code>len(rf.log)</code> 和当前<code>rf.nextIndex</code></li>
<li>两个 RPC，candidate 和 leader 处理 reply 的时候，一定要对齐 term，而不是先判断  <code>contextLost</code></li>
</ol>
<h1>要点总结</h1>
<ol>
<li>初始化时，给一条空日志作为哨兵，可以减少很多边界判断：
<ol>
<li>可以无脑取最后一条日志，而不用担心是否为空</li>
<li>在试探后退时，可以退到 0 的位置，而非 -1</li>
</ol>
</li>
<li>Leader 的两个数组，本质上是 Leader 对全局 Peer 的 Log 的两个视图：
<ol>
<li><code>nextIndex</code>：试探点视图，用于寻找 Leader 和 Follower 的日志匹配点</li>
<li><code>matchIndex</code>：匹配点视图，收到成功的 <code>AppendEntriesReply</code> 后更新，进而计算 <code>CommitIndex</code></li>
</ol>
</li>
<li>日志同步分两个阶段（两个阶段都有心跳的作用），分别对应上面两个数组，分水岭是第一次同步成功：
<ol>
<li>Backtracking：探测匹配点</li>
<li>Appending：正常同步日志</li>
</ol>
</li>
<li><code>tmpIndexes := rf.matchIndex[:] </code>不会复制。得新建一个 Slice，然后使用 copy 函数。</li>
<li>如果要进行日志探测优化，最好封装两个函数：
<ol>
<li>firstEntryForTermLocked</li>
<li>lastEntryForTermLocked</li>
</ol>
</li>
</ol>
<h1>测试逻辑</h1>
<ol>
<li>cfg.one 由于要判断 cfg.nCommitted(index) &gt; expectedServers，因此最少需要两轮心跳，第一轮同步日志，第二轮同步 CommitIndex。由此观之，测试的主要占时大头由 ReplicateInterval 决定。</li>
<li>测试逻辑：大概是混沌运行一段时间，然后最后将所有连通，看在 10s 内是否所有 peer 都能 apply 完（在 one 里）。
<ol>
<li>如果联通后， append 一条日志。此时 没有 apply</li>
<li>由于某个 follower 超时（比如并发过高），变更 leader 后，</li>
<li>由于没有新的日志 append 过来，但无法 commit 老 term 的日志，导致不能 apply 该日志</li>
<li>感觉只能通过 leader 上台提交一条新的日志来解决了，但这样无法过 2B</li>
</ol>
</li>
<li>在工业界，常用 Leader 上台后 append 一个空日志，以让 <code>leaderCommit</code> 尽快更新
<ol>
<li>但在本实验中会让 2B 挂掉，所以不能这么干，因为 PartB 的测试依赖 tester 眼中的 index。</li>
</ol>
</li>
<li>之前以为 <code>TestBackupPartB</code> 耗时是因为在试探阶段，因此着重优化 Backtracking，发现效果不大：
<ol>
<li>如果每次 nextIndex 线性 -1，该测试用例用时 50s</li>
<li>改成取回 Follower.LastLogTerm，从小于 LastLogTerm 的第一个 Term 开始试探，用时 30s</li>
<li>使用 Students’ Guide to Raft  提到的算法，最后也是 30s</li>
</ol>
</li>
<li>后面在看了测试逻辑之后发现，因为其测试逻辑涉及几十个  Start-&gt;Check All Commit 的过程。每一次写 Leader 到日志真正提交至少需要两个 <code>replicationInterval</code>，一次用于分发日志，一次用于同步 <code>LeaderCommit</code>。因此该测试的优化并不在试探阶段，而在同步阶段。有两种方法：最简单粗暴的就是缩小 <code>replicationInterval</code>；另一个就是在每次 <code>Start</code> 之后立即发送 <code>AppendEntries</code> 请求，而不是等到一个 <code>replicationInterval</code> 之后。</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>17. Raft PartD 日志压缩</title>
    <url>//c7b2b173.html</url>
    <content><![CDATA[<h1>实现要求</h1>
<p>对于一个长时间运行的 Raft 系统，如果持续收到日志，会遇到以下问题：</p>
<ol>
<li><strong>空间不够</strong>：如果日志无限追加下去，本地硬盘空间可能存不下。</li>
<li><strong>重启过慢</strong>：因为重启时需要重放（ replay）所有日志，如果日志过长，重放过程将会持续很久不能正常对外提供服务。</li>
</ol>
<p>一个经典的解决办法是，定期对日志做<strong>快照</strong>（snapshot）。针对某个日志 entry 做了快照之后，该 entry 以及以前的日志变都可以被<strong>截断</strong>（<strong>truncate</strong>）。当然，这种方法能解决的我们上面两个问题的本质原因在于：相比日志，快照的存储更为紧凑。日志记录的是事件（比如 <code>update k1 = v2</code>），而快照通常记录的是数据条目（比如 <code>&#123;k1: v1, k2: v2&#125;</code>），而一个数据条目通常会在事件中出现多次（写入-更新-删除等等），因此从日志到快照通常会有压缩空间。</p>
<p>但这样同时会引出另一个问题：如果 Leader 想给从节点发送日志时，发现相关日志条目已经被截断怎么办？这就需要引入一个新的 RPC：<code>InstallSnapshot</code>。通过此 RPC，先将 Leader 的 Snapshot 无脑同步给 Follower，再做之后日志同步。<a href="https://raft.github.io/raft.pdf">Raft 论文</a>中第七章提到了该 RPC，可以进行参考，但具体是细节还需要你来设计。</p>
<p>最终，你的 Raft 实现需要对外提供以下接口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Snapshot(index int, snapshot []byte)</span><br></pre></td></tr></table></figure>
<p>在 PartD 的测试中，测试框架会定期调用该接口，其含义大致是：<strong>应用层</strong>表示我在 index 处做了一个 snapshot，<strong>raft 层</strong>可以记下该 snapshot，并且把 index 以及以前的日志给删掉了。</p>
<p>需要注意的是，测试框架会在每个 Peer （而非只在 Leader） 上，调用该接口。</p>
<p>我们重新梳理一遍你需要实现的内容：</p>
<ol>
<li>实现一个 <code>Snapshot()</code> 接口，承接应用层来的快照请求</li>
<li>实现一套 <code>InstallSnapshot </code> RPC，当日志同步时发现日志被截断时先同步 Snapshot</li>
</ol>
<p>在 1 中，你需要将应用层传下来的 snapshot 存储下来，以备 2 使用。此外，在 2 中，如果 Follower 接受到 snapshot 时，也需要将其存下来，以备<strong>重启</strong>或者将来变成 <strong>Leader 使用</strong>。在这两种情况下，你都可以使用 <code>persister.Save()</code> 来存。</p>
<p>在 Raft 因为宕机重启时，如果有 snapshot，那么第一步就是要先应用 snapshot。你可以往 <code>applyCh</code> 中发一个 <code>ApplyMsg</code> 来应用 snapshot。当然，此处的 <code>ApplyMsg</code> 要用上之前 lab 没有使用的其他字段了，就是下面代码中的 For PartD 部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ApplyMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">        CommandValid <span class="type">bool</span></span><br><span class="line">        Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">        CommandIndex <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// For PartD:</span></span><br><span class="line">        SnapshotValid <span class="type">bool</span></span><br><span class="line">        Snapshot      []<span class="type">byte</span></span><br><span class="line">        SnapshotTerm  <span class="type">int</span></span><br><span class="line">        SnapshotIndex <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>实现要点</h1>
<ol>
<li>作为基础，可以先改造下日志的实现，让其支持从某个下标（比如 X ）开始。在 PartB/PartC 中，X 可以设置为 0，以跑过测试；在 PartD 中，在收到 <code>Snapshot(index, snapshot)</code> 请求时，可以将 X 设置为 <code>index</code>，并截断 <code>index</code> 以及以前的日志。如果你这一步做对了，就可以跑过 PartD 的第一个测试：<code>TestSnapshotBasicPartD</code>。</li>
<li>注意使用 Golang 中的切片进行截断时，底层可能并没有真正的丢弃数据，因此需要使用：比如新建+拷贝替代切片，以保证 GC 真正会回收相应空间。</li>
<li>不需要实现论文中<strong>增量</strong>发送 Snapshot（因为实践中 Snapshot 可能过大） ，我们实验中只需一次<strong>全量</strong>发送即可。因此论文中图 13 的 <code>offset</code> 是不需要的。</li>
<li>尽管在调用 <code>Snapshot(index, snapshot)</code> 时，index 处的日志被丢掉了。但在发送 AppendEntries 时，可能会用到该 index（即当前存留日志的前一条、也是 snapshot 的最后一条）term，因此你最好将其保存下来：<code>lastIncludeTerm</code>/<code>lastIncludeIndex</code>。另外需要考虑下，他们是否需要进行持久化，以应对宕机重启。</li>
<li><code>Snapshot(index, snapshot)</code> 只能针对已提交的日志做快照，因此最好检查下 index 和 <code>CommitIndex</code> 的关系。</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>16. Raft PartC 调试和小结</title>
    <url>//7177791d.html</url>
    <content><![CDATA[<p>工欲善其事，必先利其器。这次在调试之前，我们首先再加一些之前没有加到位的调试日志。有了这些关键环节的日志，我们就可以追踪日志试探匹配过程中<strong>冲突</strong>以及<strong>后撤</strong>的 index 变迁轨迹和当时 Leader、Follower 两方日志构成。有了这些，即使我们一开始实现出错，也可以根据这些信息来修正我们的优化算法。</p>
<h1>加些日志</h1>
<p>由于大部分时候我们并不需要特别详细的信息，因此我们将这些日志信息大多都加为 Debug 级别，可以通过设置 <code>VERBOSE = 0</code> 来打印，<code>VERBOSE = 1 </code> 来关闭对 Debug 日志的打印。</p>
<h2 id="RPC-收发信息">RPC 收发信息</h2>
<p>每个 RPC 发送出去、收到的时候，都可以打印下关键参数信息。为了复用，我们可以给 RPC 用到的 XXXArgs 各自构造一个 format 好的 <code>String()</code> 函数。且尽量的简洁的打印信息。</p>
<p>领导选举模块收发信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(args *RequestVoteArgs)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Candidate-%d T%d, Last:[%d]T%d&quot;</span>, args.CandidateId, args.Term, args.LastLogIndex, args.LastLogTerm)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reply *RequestVoteReply)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;T%d, VoteGranted: %v&quot;</span>, reply.Term, reply.VoteGranted)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- in raft_election.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA, PartB).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, VoteAsked, Args=%v&quot;</span>, args.CandidateId, args.String())</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection(term <span class="type">int</span>) &#123;</span><br><span class="line">        askVoteFromPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">                reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">                ok := rf.sendRequestVote(peer, args, reply)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// handle the reponse</span></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Ask vote, Lost or error&quot;</span>, peer)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, AskVote Reply=%v&quot;</span>, peer, reply.String())</span><br><span class="line">                <span class="comment">// ...... some code omitted</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        votes++</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                args := &amp;RequestVoteArgs&#123;</span><br><span class="line">                        Term:         rf.currentTerm,</span><br><span class="line">                        CandidateId:  rf.me,</span><br><span class="line">                        LastLogIndex: l - <span class="number">1</span>,</span><br><span class="line">                        LastLogTerm:  rf.log[l<span class="number">-1</span>].Term,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, AskVote, Args=%v&quot;</span>, peer, args.String())</span><br><span class="line">                <span class="keyword">go</span> askVoteFromPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：可以看出接收方只打印了 Args 相关信息，这是因为 Reply 信息在已经在各种处理路径中都打印了。</p>
<p>日志复制模块收发信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(args *AppendEntriesArgs)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Leader-%d, T%d, Prev:[%d]T%d, (%d, %d], CommitIdx: %d&quot;</span>,</span><br><span class="line">                args.LeaderId, args.Term, args.PrevLogIndex, args.PrevLogTerm,</span><br><span class="line">                args.PrevLogIndex, args.PrevLogIndex+<span class="built_in">len</span>(args.Entries), args.LeaderCommit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reply *AppendEntriesReply)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;T%d, Sucess: %v, ConflictTerm: [%d]T%d&quot;</span>, reply.Term, reply.Success, reply.ConfilictIndex, reply.ConfilictTerm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- in raft_replication.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, Appended, Args=%v&quot;</span>, args.LeaderId, args.String())</span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">                ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Lost or crashed&quot;</span>, peer)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Append, Reply=%v&quot;</span>, peer, reply.String())</span><br><span class="line">                <span class="comment">// ...... some code omitted</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        rf.matchIndex[peer] = <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">                        rf.nextIndex[peer] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                prevIdx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                prevTerm := rf.log[prevIdx].Term</span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        Term:         rf.currentTerm,</span><br><span class="line">                        LeaderId:     rf.me,</span><br><span class="line">                        PrevLogIndex: prevIdx,</span><br><span class="line">                        PrevLogTerm:  prevTerm,</span><br><span class="line">                        Entries:      rf.log[prevIdx+<span class="number">1</span>:],</span><br><span class="line">                        LeaderCommit: rf.commitIndex,</span><br><span class="line">                &#125;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Append, %v&quot;</span>, peer, args.String())</span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="试探阶段信息">试探阶段信息</h2>
<p>包括发送方的<strong>试探信息</strong>（<code>nextIndex</code> 轨迹）、接收方的<strong>冲突信息</strong>（<code>conflictTerm</code> 和 <code>conflictIndex</code> 信息），以及两方当时的 Log 信息。</p>
<p>为了方便复用格式化日志的代码，我们给他封装个函数。我们以 <code>[startIndex, endIndex]TXX</code> 形式来按 term 粒度压缩日志信息。也就是简单按 term 归并了下同类项，否则日志信息会过于长，不易阅读。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- in raft.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> logString() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> terms <span class="type">string</span></span><br><span class="line">        prevTerm := rf.log[<span class="number">0</span>].Term</span><br><span class="line">        prevStart := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.log); i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> rf.log[i].Term != prevTerm &#123;</span><br><span class="line">                        terms += fmt.Sprintf(<span class="string">&quot; [%d, %d]T%d;&quot;</span>, prevStart, i<span class="number">-1</span>, prevTerm)</span><br><span class="line">                        prevTerm = rf.log[i].Term</span><br><span class="line">                        prevStart = i</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        terms += fmt.Sprintf(<span class="string">&quot; [%d, %d]T%d;&quot;</span>, prevStart, <span class="built_in">len</span>(rf.log)<span class="number">-1</span>, prevTerm)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> terms</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送方试探信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- in raft_replication.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                <span class="comment">// ...... some code omitted</span></span><br><span class="line">               </span><br><span class="line">                <span class="comment">// hanle the reply</span></span><br><span class="line">                <span class="comment">// probe the lower index if the prevLog not matched</span></span><br><span class="line">                <span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">                        prevIndex := rf.nextIndex[peer]</span><br><span class="line">                        <span class="keyword">if</span> reply.ConfilictTerm == InvalidTerm &#123;</span><br><span class="line">                                rf.nextIndex[peer] = reply.ConfilictIndex</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                firstIndex := rf.firstLogFor(reply.ConfilictTerm)</span><br><span class="line">                                <span class="keyword">if</span> firstIndex != InvalidIndex &#123;</span><br><span class="line">                                        rf.nextIndex[peer] = firstIndex</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        rf.nextIndex[peer] = reply.ConfilictIndex</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// avoid unordered reply</span></span><br><span class="line">                        <span class="comment">// avoid the late reply move the nextIndex forward again</span></span><br><span class="line">                        <span class="keyword">if</span> rf.nextIndex[peer] &gt; prevIndex &#123;</span><br><span class="line">                                rf.nextIndex[peer] = prevIndex</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Not matched at Prev=[%d]T%d, Try next Prev=[%d]T%d&quot;</span>, peer, args.PrevLogIndex, rf.log[args.PrevLogIndex].Term, rf.nextIndex[peer]<span class="number">-1</span>, rf.log[rf.nextIndex[peer]<span class="number">-1</span>].Term)</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;Leader log=%v&quot;</span>, rf.logString())</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ...... some code omitted</span></span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收方冲突信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, Append, Prev=[%d]T%d, Commit: %d&quot;</span>, args.LeaderId, args.PrevLogIndex, args.PrevLogTerm, args.LeaderCommit)</span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject log, Higher term, T%d&lt;T%d&quot;</span>, args.LeaderId, args.Term, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                rf.resetElectionTimerLocked()</span><br><span class="line">                <span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Follower Conflict: [%d]T%d&quot;</span>, args.LeaderId, reply.ConfilictIndex, reply.ConfilictTerm)</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;Follower log=%v&quot;</span>, rf.logString())</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>调试</h1>
<p>在跑整体测试的时候，发现针对 Figure 8 的测试没有通过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">test</span> -run PartC</span> </span><br><span class="line">Test (PartC): basic persistence ...</span><br><span class="line">  ... Passed --   3.4  3  120   30695    6</span><br><span class="line">Test (PartC): more persistence ...</span><br><span class="line">  ... Passed --  14.3  5 1240  271228   16</span><br><span class="line">Test (PartC): partitioned leader and one follower crash, leader restarts ...</span><br><span class="line">  ... Passed --   1.1  3   44   11285    4</span><br><span class="line">Test (PartC): Figure 8 ...</span><br><span class="line">0: log map[1:7872615498129679323 2:1897413406896793835 3:3934096519556870059 4:5753996391082549933 5:1987667707975356298 6:1523406137084587794 7:3756591963411462759]; server map[1:7872615498129679323 2:1897413406896793835 3:3934096519556870059 4:5753996391082549933 5:1987667707975356298 6:1523406137084587794 7:3756591963411462759 8:4535228716752658303 9:6839402622095127600]</span><br><span class="line">0: log map[1:7872615498129679323 2:1897413406896793835 3:3934096519556870059 4:5753996391082549933 5:1987667707975356298 6:1523406137084587794 7:3756591963411462759]; server map[1:7872615498129679323 2:1897413406896793835 3:3934096519556870059 4:5753996391082549933 5:1987667707975356298 6:1523406137084587794 7:3756591963411462759 8:4535228716752658303 9:6839402622095127600]</span><br><span class="line">0: log map[1:7872615498129679323 2:1897413406896793835 3:3934096519556870059 4:5753996391082549933 5:1987667707975356298 6:1523406137084587794 7:3756591963411462759]; server map[1:7872615498129679323 2:1897413406896793835 3:3934096519556870059 4:5753996391082549933 5:1987667707975356298 6:1523406137084587794 7:3756591963411462759 8:4535228716752658303 9:6839402622095127600]</span><br><span class="line">apply error: commit index=8 server=0 982221549951123211 != server=4 4535228716752658303</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    course/raft     26.008s</span><br></pre></td></tr></table></figure>
<p>联系论文中相关配图：</p>
<p><img src="./assets/16-1.png" alt="16-1"></p>
<p>可以想到是一个重要的 bug：Leader 只能提交本 Term 的日志。在 <code>raft_replicaton.go</code> 中，将更新 <code>commitIndex</code> 的条件改掉就行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">                ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ...... some code ommited</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// update match/next index if log appended successfully</span></span><br><span class="line">                rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries) <span class="comment">// important</span></span><br><span class="line">                rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// update the commitIndex</span></span><br><span class="line">                majorityMatched := rf.getMajorityIndexLocked()</span><br><span class="line">                <span class="keyword">if</span> majorityMatched &gt; rf.commitIndex &amp;&amp; rf.log[majorityMatched].Term == rf.currentTerm &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Leader update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, majorityMatched)</span><br><span class="line">                        rf.commitIndex = majorityMatched</span><br><span class="line">                        rf.applyCond.Signal()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...... some code ommited</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以发现 race 测试、高并发测试都可以跑过了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  raft git:(example) go test -run PartC -race</span><br><span class="line">Test (PartC): basic persistence ...</span><br><span class="line">  ... Passed --   4.9  3  166   44344    7</span><br><span class="line">Test (PartC): more persistence ...</span><br><span class="line">  ... Passed --  14.8  5 1264  277596   16</span><br><span class="line">Test (PartC): partitioned leader and one follower crash, leader restarts ...</span><br><span class="line">  ... Passed --   1.2  3   42   11253    4</span><br><span class="line">Test (PartC): Figure 8 ...</span><br><span class="line">  ... Passed --  36.0  5 1936  406861   44</span><br><span class="line">Test (PartC): unreliable agreement ...</span><br><span class="line">  ... Passed --   4.0  5  233   85774  246</span><br><span class="line">Test (PartC): Figure 8 (unreliable) ...</span><br><span class="line">  ... Passed --  39.3  5 4988 9210073  374</span><br><span class="line">Test (PartC): churn ...</span><br><span class="line">  ... Passed --  16.4  5 1020  988536  545</span><br><span class="line">Test (PartC): unreliable churn ...</span><br><span class="line">  ... Passed --  16.4  5 1527 1984672  228</span><br><span class="line">PASS</span><br><span class="line">ok      course/raft     133.250s</span><br><span class="line">➜  raft git:(example) dstest PartC  -p 30 -n 100</span><br><span class="line"> Verbosity level set to 0</span><br><span class="line">┏━━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━┓</span><br><span class="line">┃ Test       ┃ Failed      ┃ Total      ┃          Time           ┃</span><br><span class="line">┡━━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━━━━┩</span><br><span class="line">│ PartC      │      0      │   100      │      124.70 ± 4.35      │</span><br><span class="line">└───────┴────────┴───────┴───────────────┘</span><br></pre></td></tr></table></figure>
<h1>检查列表</h1>
<p>下面给出一些 PartC 可能有问题的检查列表，如果你的代码有问题，但是调了半天没有调出来，可以参考以下信息。</p>
<ol>
<li>只能提交本 term 日志，不然 <code>TestFigure8PartC</code> 过不了。</li>
<li>通过当选的 leader 可以及早 truncate 一些 Follower 的日志，以使之后快速收敛。测试了下似乎差别不大。</li>
<li>优化：收到 Start 就可以发 RPC，不然得等到下一个心跳间隔才能发；但是也不要发太频繁，不然一下 Start 五十个。</li>
<li>注意 <code>reply.ConflictIndex</code> 是 <code>reply.ConflictTerm </code>的第一项而不是 <code>args.PrevTerm</code> 的第一项。</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>18. Raft PartD 日志重构</title>
    <url>//f64e6a5d.html</url>
    <content><![CDATA[<p>要支持 Compaction，需要对日志进行诸多改造。干脆，我们将相关逻辑封装到一个 <code>struct</code> 中。</p>
<p>于是我们新创建一个 <code>RaftLog</code> 的结构体，以支持：</p>
<ol>
<li><strong>在 index 处进行 Snapshot</strong>：将 index 以及之前的日志阶段掉</li>
<li>基本读写操作：
<ol>
<li><strong>读取</strong>：在 Snapshot 存在时，需要做下标转换，但在没有 Snapshot 时又不用，需要想办法进行统一。</li>
<li><strong>追加</strong>：包括在末尾追加（用于应用层给 Leader 追加日志）、在给定下标处覆盖追加（用于 Leader 覆写 Follower 日志）等等。</li>
</ol>
</li>
</ol>
<p>当然，以上需求是在有一个基本想法之后，再去看其他所有使用到 <code>RaftLog</code> 的代码，然后总结出来的。但为了行文方便，我直接放在了开始，所以乍一看会有些突兀。</p>
<h1>RaftLog 实现</h1>
<h2 id="结构体字段">结构体字段</h2>
<p>我们新建一个文件，起名为 <code>raft_log.go </code>，然后定义一个 <code>RaftLog</code> 的结构体。主要包含三部分：</p>
<ol>
<li>前面日志截断后 compact 成的 <code>snapshot</code></li>
<li>后面的剩余日志 <code>tailLog</code></li>
<li>两者的<strong>分界线</strong>，也就是上一节要求中提到的：<code>lastIncludeTerm</code>/<code>lastIncludeIndex</code>，这里我们给他加上 snap 前缀，可以更直观一些，知道是 snapshot 最后的下标和任期，即 <code>snapLastIdx</code> / <code>snapLastTerm</code> 。</li>
</ol>
<p>这里有个巧妙的设计点，可以避免边界判断、一致化下标转换。即，将 <code>tailLog</code> 中下标为 0 （对应 <code>snapLastIdx</code>）的日志留空，但给其的 <code>Term</code> 字段赋值 <code>snapLastTerm</code>，真正的下标从 1 （对应 <code>snapLastIdx</code>+1）开始。</p>
<p>这样做有什么好处呢？更具体来说就是：</p>
<ol>
<li><strong>边界判断</strong>：在进行日志复制时，需要取所发送日志的 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 时，可以避免特殊判断。</li>
<li><strong>下标转换</strong>：所有的全局下标转到 <code>tailLog</code> 下标时，只需要减去 <code>snapLastIdx</code> 即可</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftLog <span class="keyword">struct</span> &#123;</span><br><span class="line">        snapLastIdx  <span class="type">int</span></span><br><span class="line">        snapLastTerm <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// contains index [1, snapLastIdx]</span></span><br><span class="line">        snapshot []<span class="type">byte</span></span><br><span class="line">        <span class="comment">// the first entry is `snapLastIdx`, but only contains the snapLastTerm</span></span><br><span class="line">        <span class="comment">// the entries between (snapLastIdx, snapLastIdx+len(tailLog)-1] have real data</span></span><br><span class="line">        tailLog []LogEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换个角度理解，就是我们在 <code>tailLog</code> 的开始 mock 了一个假的 snapshot 的 <code>lastIncludeEntry</code>。且当 snapshot 为空时，该 <code>lastIncludeEntry</code> 的 index 和 term 都是 0（我们在[Raft PartC 实现和优化]定义的边界常量） 。</p>
<h2 id="初始化">初始化</h2>
<p>对 RaftLog 初始化，有两条路径：</p>
<ol>
<li><strong>构造函数</strong>：在通过 Make 构造 Raft 实例时使用，此时各个字段留默认值就行。</li>
<li><strong>反序列化函数</strong>：读取宕机前（如果有）持久化的各个字段，对 <code>RaftLog</code> 进行填充。</li>
</ol>
<p>且通常，两个是在 Make 函数中先后执行，因此构造函数其实可以留空，但下面我们为了将来的可扩展性仍然实现了，仅在调用时传空。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// called as : rf.log = NewLog(InvalidIndex, InvalidTerm, nil, nil)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLog</span><span class="params">(snapLastIdx, snapLastTerm <span class="type">int</span>, snapshot []<span class="type">byte</span>, entries []LogEntry)</span></span> *RaftLog &#123;</span><br><span class="line">        rl := &amp;RaftLog&#123;</span><br><span class="line">                snapLastIdx:  snapLastIdx,</span><br><span class="line">                snapLastTerm: snapLastTerm,</span><br><span class="line">                snapshot:     snapshot,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// make the len = 0, cap = 1 + len(entries)</span></span><br><span class="line">        rl.tailLog := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>, <span class="number">1</span> + <span class="built_in">len</span>(entries)) </span><br><span class="line">        rl.tailLog = <span class="built_in">append</span>(rl.tailLog, LogEntry&#123;</span><br><span class="line">                Term: snapLastTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        rl.tailLog = <span class="built_in">append</span>(rl.tailLog, entries...)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return detailed error for the caller to log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> readPersist(d *labgob.LabDecoder) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> lastIdx <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;lastIdx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decode last include index failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        rl.snapLastIdx = lastIdx</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> lastTerm <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;lastTerm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decode last include term failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        rl.snapLastTerm = lastTerm</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> log []LogEntry</span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;log); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decode tail log failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        rl.tailLog = log</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> persist(e *labgob.LabEncoder) &#123;</span><br><span class="line">        e.Encode(rl.snapLastIdx)</span><br><span class="line">        e.Encode(rl.snapLastTerm)</span><br><span class="line">        e.Encode(rl.tailLog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下标操作">下标操作</h2>
<p>在实现时，最容易弄混的就是下标操作，最主要的原因，就是要做下标转换。但好在我们上面 <code>snapLastIdx</code> 设定就是 <code>tailLog[0]</code> 的位置，因此从全局下标（<code>logicIdx</code>），转为 <code>tailLog</code> 局部下标，只需要和 <code>snapLastIdx</code> 做差值即可。反过来转换，只需要加上 <code>snapLastIdx</code> 即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the dummy log is counted</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> size() <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rl.snapLastIdx + <span class="built_in">len</span>(rl.tailLog)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// access the index `rl.snapLastIdx` is allowed, although it&#x27;s not exist actually.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> idx(logicIdx <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> logicIdx &lt; rl.snapLastIdx || logicIdx &gt;= rl.size() &#123;</span><br><span class="line">                <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%d is out of [%d, %d]&quot;</span>, logicIdx, rl.snapLastIdx+<span class="number">1</span>, rl.size()<span class="number">-1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> logicIdx - rl.snapLastIdx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> at(logicIdx <span class="type">int</span>) LogEntry &#123;</span><br><span class="line">        <span class="keyword">return</span> rl.tailLog[rl.idx(logicIdx)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串函数">字符串函数</h2>
<p>主要是为了打印供调试的日志使用，我们将其分成两个：</p>
<ol>
<li>用以输出详细日志：进行深度追踪时用，频次要低，且通常用在 Debug 级别</li>
<li>用以输出粗略日志：较为简短，可以使用频次稍高</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// more detailed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> terms <span class="type">string</span></span><br><span class="line">        prevTerm := rl.snapLastTerm</span><br><span class="line">        prevStart := rl.snapLastIdx</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rl.tailLog); i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> rl.tailLog[i].Term != prevTerm &#123;</span><br><span class="line">                        terms += fmt.Sprintf(<span class="string">&quot; [%d, %d]T%d&quot;</span>, prevStart, i<span class="number">-1</span>, prevTerm)</span><br><span class="line">                        prevTerm = rl.tailLog[i].Term</span><br><span class="line">                        prevStart = i</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        terms += fmt.Sprintf(<span class="string">&quot;[%d, %d]T%d&quot;</span>, prevStart, <span class="built_in">len</span>(rl.tailLog)<span class="number">-1</span>, prevTerm)</span><br><span class="line">        <span class="keyword">return</span> terms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// more simplified</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> Str() <span class="type">string</span> &#123;</span><br><span class="line">        lastIdx, lastTerm := rl.last()</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[%d]T%d~[%d]T%d&quot;</span>, rl.snapLastIdx, rl.snapLastTerm, lastIdx, lastTerm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>其他模块用到</h1>
<p>这些函数，都是通过逐一遍历其他 Raft 实现，包括选举（<code>raft_election.go</code>）、日志复制（<code>raft_replication.go</code>）、日志应用（<code>raft_application.go</code>）和公共逻辑 （<code>raft.go</code>）来逐一增补的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> last() (idx, term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rl.size() - <span class="number">1</span>, rl.tailLog[<span class="built_in">len</span>(rl.tailLog)<span class="number">-1</span>].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> tail(startIdx <span class="type">int</span>) []LogEntry &#123;</span><br><span class="line">        <span class="keyword">if</span> startIdx &gt;= rl.size() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rl.tailLog[rl.idx(startIdx):]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> firstLogFor(term <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> idx, entry := <span class="keyword">range</span> rl.tailLog &#123;</span><br><span class="line">                <span class="keyword">if</span> entry.Term == term &#123;</span><br><span class="line">                        <span class="keyword">return</span> idx</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> entry.Term &gt; term &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> InvalidIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> <span class="built_in">append</span>(e LogEntry) &#123;</span><br><span class="line">        rl.tailLog = <span class="built_in">append</span>(rl.tailLog, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> appendFrom(prevIdx <span class="type">int</span>, entries []LogEntry) &#123;</span><br><span class="line">        rl.tailLog = <span class="built_in">append</span>(rl.tailLog[:rl.idx(prevIdx)+<span class="number">1</span>], entries...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Snapshot 基本实现</h1>
<p>本节就只实现基本的 <code>Snapshot(index, snapshot)</code> 函数即可。相关 RPC 留到下一节实现，PartD 的第一个测试 <code>TestSnapshotBasicPartD</code> 保证不会用到 <code>InstallSnapshot</code> RPC 相关的逻辑。</p>
<p>该函数的基本含义为：应用层在 index 处做了个快照，Raft 层帮我把该快照保存下，同时，index 以及之前的日志就可以释放掉了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the service says it has created a snapshot that has</span></span><br><span class="line"><span class="comment">// all info up to and including index. this means the</span></span><br><span class="line"><span class="comment">// service no longer needs the log through (and including)</span></span><br><span class="line"><span class="comment">// that index. Raft should now trim its log as much as possible.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartD).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;Snap on %d&quot;</span>, index)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt;= rf.log.snapLastIdx || index &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;Could not snapshot beyond [%d, %d]&quot;</span>, rf.log.snapLastIdx+<span class="number">1</span>, rf.commitIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.log.doSnapshot(index, snapshot)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行日志截断的时候，注意要新建一个数组，而不要直接使用下标切片运算。只有新建数组并切换过去，才会真正的解掉对于原来数组的引用，保证 golang GC 可以将原来数组的空间释放掉。</p>
<p>另外要注意的是—— <code>rl.idx()</code> 函数会用到<code>rl.snapLastIdx</code> ，而我们本函数也要修改 <code>rl.snapLastIdx</code>，因此一定要注意他们使用和修改的先后顺序，否则会出现不符合预期的问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_log.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> doSnapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="comment">// since idx() will use rl.snapLastIdx, so we should keep it first</span></span><br><span class="line">        idx := rl.idx(index)</span><br><span class="line"></span><br><span class="line">        rl.snapLastTerm = rl.tailLog[idx].Term</span><br><span class="line">        rl.snapLastIdx = index</span><br><span class="line">        rl.snapshot = snapshot</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allocate a new slice</span></span><br><span class="line">        newLog := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>, rl.size()-rl.snapLastIdx)</span><br><span class="line">        newLog = <span class="built_in">append</span>(newLog, LogEntry&#123;</span><br><span class="line">                Term: rl.snapLastTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        newLog = <span class="built_in">append</span>(newLog, rl.tailLog[idx+<span class="number">1</span>:]...)</span><br><span class="line">        rl.tailLog = newLog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>测试</h1>
<p>实现完 RaftLog 之后，我们要将所有 PartA~PartC 的测试跑过，保证我们的实现没有影响之前的逻辑。</p>
<p>从这个角度可以看出测试的重要性，他是保证我们代码“不变性”（invariant）的重要手段，有了这些单测，你在重构时才可以放心的说，尽管我改了很多，但是我的代码功能上没有问题——当然，这也依赖于测试的完备性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;PartA PartB PartC&#x27;</span> | xargs -n1 go <span class="built_in">test</span> -run</span> </span><br><span class="line"></span><br><span class="line">Test (PartA): initial election ...</span><br><span class="line">  ... Passed --   3.0  3   88   25020    0</span><br><span class="line">Test (PartA): election after network failure ...</span><br><span class="line">  ... Passed --   4.5  3  190   38737    0</span><br><span class="line">Test (PartA): multiple elections ...</span><br><span class="line">  ... Passed --   5.6  7  941  193306    0</span><br><span class="line">PASS</span><br><span class="line">ok      course/raft     13.309s</span><br><span class="line">Test (PartB): basic agreement ...</span><br><span class="line">  ... Passed --   0.5  3   22    5616    3</span><br><span class="line">Test (PartB): RPC byte count ...</span><br><span class="line">  ... Passed --   1.8  3   54  115708   11</span><br><span class="line">Test (PartB): test progressive failure of followers ...</span><br><span class="line">  ... Passed --   4.4  3  176   37379    3</span><br><span class="line">Test (PartB): test failure of leaders ...</span><br><span class="line">  ... Passed --   4.8  3  268   60323    3</span><br><span class="line">Test (PartB): agreement after follower reconnects ...</span><br><span class="line">  ... Passed --   5.6  3  174   47871    8</span><br><span class="line">Test (PartB): no agreement if too many followers disconnect ...</span><br><span class="line">  ... Passed --   3.3  5  303   62214    3</span><br><span class="line">Test (PartB): concurrent Start()s ...</span><br><span class="line">  ... Passed --   0.7  3   22    5644    6</span><br><span class="line">Test (PartB): rejoin of partitioned leader ...</span><br><span class="line">  ... Passed --   6.2  3  262   67089    4</span><br><span class="line">Test (PartB): leader backs up quickly over incorrect follower logs ...</span><br><span class="line">  ... Passed --  20.6  5 2498 1949990  102</span><br><span class="line">Test (PartB): RPC counts aren’t too high ...</span><br><span class="line">  ... Passed --   2.2  3   70   20424   12</span><br><span class="line">PASS</span><br><span class="line">ok      course/raft     50.123s</span><br><span class="line">Test (PartC): basic persistence ...</span><br><span class="line">  ... Passed --   5.0  3  172   46581    7</span><br><span class="line">Test (PartC): more persistence ...</span><br><span class="line">  ... Passed --  14.5  5 1258  276538   16</span><br><span class="line">Test (PartC): partitioned leader and one follower crash, leader restarts ...</span><br><span class="line">  ... Passed --   1.2  3   46   11891    4</span><br><span class="line">Test (PartC): Figure 8 ...</span><br><span class="line">  ... Passed --  28.5  5 1576  328781   36</span><br><span class="line">Test (PartC): unreliable agreement ...</span><br><span class="line">  ... Passed --   3.9  5  238   85079  246</span><br><span class="line">Test (PartC): Figure 8 (unreliable) ...</span><br><span class="line">  ... Passed --  32.5  5 4412 5485489  446</span><br><span class="line">Test (PartC): churn ...</span><br><span class="line">  ... Passed --  16.4  5 1350 1008253  321</span><br><span class="line">Test (PartC): unreliable churn ...</span><br><span class="line">  ... Passed --  16.5  5 1323  808135  249</span><br><span class="line">PASS</span><br><span class="line">ok      course/raft     118.544s</span><br></pre></td></tr></table></figure>
<p>同时，要跑过 PartD 的第一个测试 <code>TestSnapshotBasicPartD</code> ，保证我们的 Snapshot 的基本逻辑没问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">VERBOSE=<span class="number">0</span> <span class="keyword">go</span> test -run TestSnapshotBasicPartD | tee out.txt</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>20. Raft PartD 调试和小结</title>
    <url>//8425f0d7.html</url>
    <content><![CDATA[<p>由于事先做了数据流图，因此总体来说 PartD 没有什么大问题。剩下有些问题，上一节中提到过一些；其他的集中在两个部分。</p>
<h1>问题修复</h1>
<p>问题包括两部分：</p>
<ol>
<li>在 Snapshot 时对 index 的检查</li>
<li>使用 <a href="http://rf.log.at">rf.log.at</a> 前对传入下标的检查</li>
</ol>
<p>这两个问题单独在 Raft 的测试中是检测不出来的，要通过之后分布式 KV 小结才能检查出来，但根据主题的亲和性，还是要放在这里讲（视频中没有提到）</p>
<h2 id="Snapshot-下标检查">Snapshot 下标检查</h2>
<p>之前只检查了下界 <code>rf.log.snapLastIdx </code>（不要重复进行 snapshot），但也要加上检查上界：<code>rf.commitIndex</code>。即，不能对没有提交的日志进行 snapshot。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_compaction.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartD).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> index &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;Couldn&#x27;t snapshot before CommitIdx: %d&gt;%d&quot;</span>, index, rf.commitIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index &lt;= rf.log.snapLastIdx &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;Already snapshot in %d&lt;=%d&quot;</span>, index, rf.log.snapLastIdx)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.log.doSnapshot(index, snapshot)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LogRaft-at-下标检查"><code>LogRaft.at</code> 下标检查</h2>
<p>每次使用 <a href="http://RaftLog.at">RaftLog.at</a> 函数时，都要保证其传入参数落入 <code>[RaftLog.snapLastIdx, RaftLog.size()-1]</code> 的区间内，有的地方可以通过逻辑来隐式保证，但有些地方由于并发的问题，必须要进行显式地检查。</p>
<p>主要包括 <code>applicationTicker</code> 的 Loop 中逻辑。Apply Log 之前会把所有 <code>(lastAppiled, commitIndex]</code> 的日志取出来，但有可能这个区间会超出 <code>rf.log</code> 中所保存的 <code>tailLog</code> 日志区间，因此要做剪裁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applicationTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.applyCond.Wait()</span><br><span class="line">                entries := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>)</span><br><span class="line">                snapPendingApply := rf.snapPending</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> !snapPendingApply &#123;</span><br><span class="line">                        <span class="keyword">if</span> rf.lastApplied &lt; rf.log.snapLastIdx &#123;</span><br><span class="line">                                rf.lastApplied = rf.log.snapLastIdx</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// make sure that the rf.log have all the entries</span></span><br><span class="line">                        start := rf.lastApplied + <span class="number">1</span></span><br><span class="line">                        end := rf.commitIndex</span><br><span class="line">                        <span class="keyword">if</span> end &gt;= rf.log.size() &#123;</span><br><span class="line">                                end = rf.log.size() - <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">                                entries = <span class="built_in">append</span>(entries, rf.log.at(i))</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// --- some code ommited here</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>通过测试</h1>
<p>如果我们在写代码前能把工程的数据流图弄得门清，就可以最大限度的减少大方面的纰漏。剩下些小的问题，通过单测就可以纠正。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  raft git:(raft) ✗ go test -run PartD</span><br><span class="line">Test (PartD): snapshots basic ...</span><br><span class="line">  ... Passed --   5.0  3  148   54742  235</span><br><span class="line">Test (PartD): install snapshots (disconnect) ...</span><br><span class="line">  ... Passed --  48.6  3 1536  583368  318</span><br><span class="line">Test (PartD): install snapshots (disconnect+unreliable) ...</span><br><span class="line">  ... Passed --  68.4  3 2168  831179  345</span><br><span class="line">Test (PartD): install snapshots (crash) ...</span><br><span class="line">  ... Passed --  71.4  3 2052  771805  364</span><br><span class="line">Test (PartD): install snapshots (unreliable+crash) ...</span><br><span class="line">  ... Passed --  75.5  3 2116  770524  365</span><br><span class="line">Test (PartD): crash and restart all servers ...</span><br><span class="line">  ... Passed --   8.8  3  292   83682   58</span><br><span class="line">Test (PartD): snapshot initialization after crash ...</span><br><span class="line">  ... Passed --   2.4  3   86   23088   14</span><br><span class="line">PASS</span><br><span class="line">ok      course/raft     280.304s</span><br><span class="line">➜  raft git:(raft) ✗ dstest PartD  -p 30 -n 100</span><br><span class="line"> Verbosity level set to 0</span><br><span class="line">Tests ━━━━━━━━━━━━━━━━━━━━╺━━━━━━━━━━━━ 0:00:53  60% 0:10:00</span><br><span class="line">╭─────────────────────────────────────────────╮        </span><br><span class="line">│ PartD ⠹ ━━━━━━━━━━━━━━━━━━━━━╺━━━━━━━━━━━━ 60/100   │        </span><br><span class="line">╰─────────────────────────────────────────────╯  </span><br><span class="line"></span><br><span class="line">➜  raft git:(raft) ✗ dstest PartD  -p 30 -n 100</span><br><span class="line"> Verbosity level set to 0</span><br><span class="line">┏━━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━┓</span><br><span class="line">┃ Test.      ┃.     Failed ┃      Total ┃                    Time ┃</span><br><span class="line">┡━━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━━━━┩</span><br><span class="line">│ PartD      │      0      │   100      │ 278.18 ± 7.05           │ </span><br><span class="line">└───────┴────────┴───────┴───────────────┘</span><br></pre></td></tr></table></figure>
<h1>注意要点</h1>
<p>由于课程录屏是在我实现过多遍后总结出的规律，因此很多大家第一遍拿到 PartD 时可能会遇到很多问题，在视频中并没有讲。这里就一次性的将我实现过程中思考过的问题罗列下。大家如果有其他问题，也可以在文档下面评论，我会选一些有共性的，追加到这里。</p>
<ol>
<li><strong>snapshot 以什么形式存储和持久化，Raft 层需不需要理解 snapshot 内部内容？</strong>
<ol>
<li>不需要，只有应用层需要感知其具体内容。 Raft 层在收到应用层 snapshot 时，只需要在内存和外存（使用 persistor 持久化）各保存一份即可。</li>
<li>之后由 Follower 的 Raft 层给到应用层进行 apply 的时候，直接给 snapshot 就可以，不用重新识别出一条条 log（也是不可能的）。</li>
</ol>
</li>
<li><strong>最终要实现成切片多次发 snapshot（像论文一样），还是简单的实现成发一次就够了？</strong>
<ol>
<li>测试框架要求一次发送就行，因为 snapshot 最大也不会太大。因为测试框架主要是针对功能进行测试的，并没有进行压力测试。</li>
<li>但实践中，们是没有办法控制 snapshot 的大小的，如果其过大，我们肯定要对其进行拆分。</li>
</ol>
</li>
<li><strong>Follower 收到 snapshot apply 的时候完全 apply？那应用层如何进行去重？Snapshot 中的 kv 带 index 吗？</strong>
<ol>
<li>应用层 Apply snapshot 时，是<strong>覆盖式</strong>（全量式，因为 Snapshot 下标肯定从 0 开始） Apply；在 Apply log 时，是<strong>增量式</strong>的 Apply。两者不同。</li>
<li>因此在 Apply snapshot 时，并不需要去重（因为不是增量式的），直接替换掉当前状态机即可。</li>
</ol>
</li>
<li><strong>不仅是 Leader 会被做 snapshot？</strong>
<ol>
<li>所有 Peer 都会，因为这是一个应用层决定的行为。</li>
<li>但除 Leader 外的其他 Peer 可能会同时收到 Leader 来的 Snapshot。</li>
<li>即，Snapshot 分两种：由应用层主动地 Snapshot；从 Leader 接收来的被动的 Snapshot。</li>
</ol>
</li>
<li><strong>应用层调用</strong> **<code>snapshot(index, snapshot)</code>**<strong>意味着 什么？</strong>
<ol>
<li>对应用层意味着：
<ol>
<li>应用已经做好了一个快照，但编解码方式之后应用层自己知道，Raft 层不感知。</li>
<li>应用层自己也会保存该快照，之后宕机重启后会先加载该快照。此时（宕机重启后） Raft 层也要记得更新自己的 <code>commitIndex</code> 和 <code>lastApplied</code>。</li>
</ol>
</li>
<li>对 Raft 层意味着：
<ol>
<li>应用层告诉 Raft 层，你可以把 index 及以前的日志给释放掉了。</li>
<li>Raft 层要保存下 Snapshot，万一其变为 Leader 之后需要给 Follower 发。</li>
<li>保存分为在内存中保存和持久化到外存。</li>
</ol>
</li>
</ol>
</li>
<li><strong>需要对原流程修改的地方？</strong>
<ol>
<li>Leader 发送 entries 的时候，要先检查要发送的 PrevLogEntry 还在不在，如果不在了，需要先发 snapshot。</li>
</ol>
</li>
<li><strong>要实现一个基于逻辑 idx 的取 log 相关的子数据结构，不然会存在大量下标翻译的过程？</strong>
<ol>
<li>这也就是我们为什么要在第一小节重新实现 RaftLog 的原因。</li>
</ol>
</li>
<li><strong>宕机重启后，</strong> <strong><code>lastApplied</code></strong> <strong>怎么初始化？</strong>
<ol>
<li><strong>如果有 snapshot 存在</strong>：则需要初始化为 snapshot 的 <code>lastIncludedIndex</code>。因为应用层肯定也是从自己 snapshot 中来恢复的。
<ol>
<li>在 Make 阶段同步的再 apply 一个 snapshot 到 <code>appplyCh</code> 中有可能会直接 block 住。</li>
<li>即使不阻塞，有时候也会遇到 <code>snapshot decode error </code>报错。</li>
</ol>
</li>
<li><strong>如果没有 snapshot 存在</strong>：那就初始化为 0 。</li>
<li><strong>如果初始化为 snapLastIndex，那前面的需要 apply 吗？</strong>
<ol>
<li>不需要，因为应用层自己会从自己保存的 snapshot 中恢复。</li>
</ol>
</li>
</ol>
</li>
<li><strong>我之前遇到一个 snapshot 持久化的问题</strong>：
<ol>
<li>每次调用 PersistLocked 的时候把通过设置  snapshot=nil 在不需要持久化 snapshot 时把 snapshot 清空了。这样在重启时，就得不到 snapshot。</li>
<li>因此：
<ol>
<li>收到 snapshot 先保存到内存中（也就是我们的 <code>RaftLog</code> 中）</li>
<li>每次持久化时，一定要读取内存中的最新 snapshot 进行持久化。</li>
</ol>
</li>
</ol>
</li>
<li><strong>注意处理</strong> <strong><code>installSnapshot</code></strong> <strong>和 applyLoop 对 applyCh 的并发问题</strong>
<ol>
<li>尽量将所有 apply （包括 apply log 和 apply snapshot）都放到 apply 线程里</li>
</ol>
</li>
<li><strong>将 snapshot 相关的也收到 log 中去</strong>
<ol>
<li>这也是我们为什么单独实现 RaftLog 的原因。</li>
<li>因为 RaftLog 本质上就包括 <code>snapshot</code> 和 <code>tailLog</code> 紧密相关的两部分。</li>
<li>也可以看出，一个合理的抽象，可以让实现理解丝滑很多。</li>
</ol>
</li>
<li><strong>在 read 不出 snapshot 或者 log 时，也要对 rf.log 初始化？</strong>
<ol>
<li>是先要对<code>rf.log</code>初始化，然后通过 Persist 读取之前持久化的内容，如果有的话，就对 <code>rf.log</code> 再更新。</li>
</ol>
</li>
</ol>
<h1>小结</h1>
<p>总结来说，在拿到 PartD 的需求时，开始最困惑的就是，snapshot 在应用层和 Raft 层的关系以及和普通日志一块进行 apply 的顺序和含义问题。</p>
<p>弄清了上述两点，再理清了“快照数据流”，并且用图画出来之后，一切就很清晰了。这样也就自然的导出——我们似乎要把日志进行重构，如是就有了自然地想法将 snapshot 和尾部的日志，封装到一块。</p>
<p>所以可以看出，思考顺序和我们的课程行文顺序是相反的。这也是我们常说的，看别人的做法，看起来很合理，但不知道怎么来的——因为大部分都是以思考过、碰壁过后，逆序的呈现的。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Raft PartD 快照数据流</title>
    <url>//c3c187c5.html</url>
    <content><![CDATA[<p>本节我们要实现 <code>InstallSnapshot</code> 相关 RPC 。为了避免丢三落四，我们遵循一条 <strong>snapshot 数据流</strong>主线，来分四个步骤，一步步实现：</p>
<ol>
<li>Leader 的应用层调用 <code>raft.Snapshot(index, snapshot)</code> 函数
<ol>
<li>保存 snapshot</li>
<li>截断日志</li>
<li>持久化</li>
</ol>
</li>
<li>Leader 在需要时使用该 <code>snapshot</code> 构造参数发送 RPC 给 Follower</li>
<li>Follower 接收到 Leader RPC 后替换本地日志，并将其持久化</li>
<li>Follower 通过 <code>ApplyMsg</code> 将 snapshot 传给 Follower 应用层</li>
</ol>
<p><img src="./assets/19-1.PNG" alt="19-1"></p>
<p>和之前一样，为了保持模块的内聚性，我们新建一个文件<code>raft_compaction.go</code> 将 <code>Snapshot()</code> 接口和 <code>InstallSnapshot</code> 相关 RPC 都放在一块。</p>
<h1>调用 <code>Snapshot()</code> 接口</h1>
<p>Leader 的应用层调用 <code>Snapshot(index, snapshot)</code> 接口后，我们会在 <code>index</code> 处截断现有日志，将 <code>snapshot</code> 保存在 <code>rf.log</code> 中，同时将其持久化，以应对可能得宕机重启。</p>
<p>这里需要说明的是，我们将 <code>RafLog</code> 中：</p>
<ol>
<li>应用层（包括 Leader 和 Follower）主动做 snapshot 的接口称为 <code>RaftLog.doSnapshot</code></li>
<li>将 Follower 收到 RPC 后被动做 snapshot 的接口称为：<code>RaftLog.installSnapshot</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_compaction.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartD).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        rf.log.doSnapshot(index, snapshot)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上一节，我们没有对 <code>snapshot</code> 字段持久化，本节，我们在 <code>rf.persistLocked() </code>接口中，需要对其进行持久化。和其他字段不同，<code>snapshot</code> 需要使用 <code>rf.persister.Save</code> 接口的第二个参数来持久化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_persistence.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persistLocked() &#123;</span><br><span class="line">        w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">        e := labgob.NewEncoder(w)</span><br><span class="line">        e.Encode(rf.currentTerm)</span><br><span class="line">        e.Encode(rf.votedFor)</span><br><span class="line">        rf.log.persist(e)</span><br><span class="line">        raftstate := w.Bytes()</span><br><span class="line">        rf.persister.Save(raftstate, rf.log.snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>发送 <code>InstallSnapshot</code></h1>
<p>当 Leader 试图给 Follower 同步日志时，如果发现要携带的 <code>AppendEntriesArgs.Entries</code> 有部分已经被截断了，则需要先发送 Snapshot 。</p>
<p>这里有个<strong>边界条件</strong>——<code>AppendEntriesArgs.PrevLogIndex</code> 等于 <code>RaftLog.snapLastIdx </code>时。由于我们上一节在 <code>RaftLog.snapLastIdx</code> 处 mock 了一个携带 <code>snapLastTerm</code> 的假的日志条目，此条件下并不需要发送 Snapshot。</p>
<p>因此，需要发送 Snapshot 的条件是：<strong><code>AppendEntriesArgs.PrevLogIndex &lt; rf.log.snapLastIdx</code></strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_replication.go</span></span><br><span class="line"><span class="comment">// only valid in the given `term`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">                ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// align the term</span></span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// check context lost</span></span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// hanle the reply</span></span><br><span class="line">                <span class="comment">// probe the lower index if the prevLog not matched</span></span><br><span class="line">                <span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">                        <span class="comment">// --- some codes omitted</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// LogEntry in `nextPrevIdx` may be truncated</span></span><br><span class="line">                        <span class="comment">// so we should check it separately </span></span><br><span class="line">                        nextPrevIdx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                        nextPrevTerm := InvalidTerm</span><br><span class="line">                        <span class="keyword">if</span> nextPrevIdx &gt;= rf.log.snapLastIdx &#123;</span><br><span class="line">                                nextPrevTerm = rf.log.at(nextPrevIdx).Term</span><br><span class="line">                        &#125;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Not matched at Prev=[%d]T%d, Try next Prev=[%d]T%d&quot;</span>,</span><br><span class="line">                                peer, args.PrevLogIndex, args.PrevLogTerm, nextPrevIdx, nextPrevTerm)</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Leader log=%v&quot;</span>, peer, rf.log.String())</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// update match/next index if log appended successfully</span></span><br><span class="line">                rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries) <span class="comment">// important</span></span><br><span class="line">                rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// update the commitIndex</span></span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Leader, term) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;Lost Leader[%d] to %s[T%d]&quot;</span>, term, rf.role, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line"></span><br><span class="line">                prevIdx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> prevIdx &lt; rf.log.snapLastIdx &#123;</span><br><span class="line">                        args := &amp;InstallSnapshotArgs&#123;</span><br><span class="line">                                Term:              rf.currentTerm,</span><br><span class="line">                                LeaderId:          rf.me,</span><br><span class="line">                                LastIncludedIndex: rf.log.snapLastIdx,</span><br><span class="line">                                LastIncludedTerm:  rf.log.snapLastTerm,</span><br><span class="line">                                Snapshot:          rf.log.snapshot,</span><br><span class="line">                        &#125;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, InstallSnap, Args=%v&quot;</span>, peer, args.String())</span><br><span class="line">                        <span class="keyword">go</span> rf.installOnPeer(peer, term, args)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                prevTerm := rf.log.at(prevIdx).Term</span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        <span class="comment">// --- some codes omitted</span></span><br><span class="line">                &#125;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Append, Args=%v&quot;</span>, peer, args.String())</span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是在 <code>raft_compaction.go</code> 中定义 <code>InstallSnapshot</code> RPC 相关结构体，并发送 RPC。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_compaction.go</span></span><br><span class="line"><span class="keyword">type</span> InstallSnapshotArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term     <span class="type">int</span></span><br><span class="line">        LeaderId <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        LastIncludedIndex <span class="type">int</span></span><br><span class="line">        LastIncludedTerm  <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        Snapshot []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(args *InstallSnapshotArgs)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Leader-%d, T%d, Last: [%d]T%d&quot;</span>, args.LeaderId, args.Term, args.LastIncludedIndex, args.LastIncludedTerm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InstallSnapshotReply <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reply *InstallSnapshotReply)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;T%d&quot;</span>, reply.Term)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendInstallSnapshot(server <span class="type">int</span>, args *InstallSnapshotArgs, reply *InstallSnapshotReply) <span class="type">bool</span> &#123;</span><br><span class="line">        ok := rf.peers[server].Call(<span class="string">&quot;Raft.InstallSnapshot&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> installOnPeer(peer, term <span class="type">int</span>, args *InstallSnapshotArgs) &#123;</span><br><span class="line">        reply := &amp;InstallSnapshotReply&#123;&#125;</span><br><span class="line">        ok := rf.sendInstallSnapshot(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;-&gt; S%d, Lost or crashed&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, InstallSnap, Reply=%v&quot;</span>, peer, reply.String())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update the match and next</span></span><br><span class="line">        <span class="keyword">if</span> args.LastIncludedIndex &gt; rf.matchIndex[peer] &#123; <span class="comment">// to avoid disorder reply</span></span><br><span class="line">                rf.matchIndex[peer] = args.LastIncludedIndex</span><br><span class="line">                rf.nextIndex[peer] = args.LastIncludedIndex + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note: we need not try to update the commitIndex again,</span></span><br><span class="line">        <span class="comment">// because the snapshot included indexes are all committed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是上面代码中的标红部分，注意点有二：</p>
<ol>
<li><strong>记得更新</strong>：在处理 <code>InstallSnapshotReply</code> 时，很容易忘了更新 <code>matchIndex</code> 和 <code>nextIndex</code>，这会造成不断重复发 <code>InstallSnapshot</code> RPC。</li>
<li><strong>条件更新</strong>：主要为了处理 RPC Reply 乱序返回的情况。仅仅在 <code>args.LastIncludedIndex &gt; rf.matchIndex[peer]</code> 才更新，这是因为，如果有多个 <code>InstallSnapshotReply</code> 乱序回来，且较小的 <code>args.LastIncludedIndex</code> 后回来的话，如果不加判断，会造成<code>matchIndex</code> 和 <code>nextIndex</code> 的反复横跳。</li>
</ol>
<h1>接受 <code>InstallSnapshot</code></h1>
<p>Follower 在收到 <code>InstallSnapshot</code> 时，还是要首先<strong>对齐 Term</strong>。之后，要判断该 Snapshot 是否有必要接受：如果本地已经有 Snapshot，且其下标已经包含 <code>args.LastIncludedIndex</code> ，则拒绝即可。见下面代码中标红部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_compaction.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, RecvSnap, Args=%v&quot;</span>, args.LeaderId, args.String())</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;&lt;- S%d, Reject Snap, Higher Term, T%d&gt;T%d&quot;</span>, args.LeaderId, rf.currentTerm, args.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if it is a RPC which is out of order</span></span><br><span class="line">        <span class="keyword">if</span> rf.log.snapLastIdx &gt;= args.LastIncludedIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;&lt;- S%d, Reject Snap, Already installed, Last: %d&gt;=%d&quot;</span>, args.LeaderId, rf.log.snapLastIdx, args.LastIncludedIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// install the snapshot</span></span><br><span class="line">        rf.log.installSnapshot(args.LastIncludedIndex, args.LastIncludedTerm, args.Snapshot)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">        rf.snapPending = <span class="literal">true</span></span><br><span class="line">        rf.applyCond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Follower <code>InstallSnapshot</code> 到 Raft 层时，需要做两件事：</p>
<ol>
<li>利用该 snapshot 重置 <code>rf.log</code> ：<code>installSnapshot</code></li>
<li>对该 snapshot 进行持久化，以供宕机重启后载入：<code>rf.persistLocked()</code></li>
</ol>
<p>两者顺序不能颠倒，因为 <code>rf.persistLocked()</code> 时需要用到 <code>rf.log</code> 中的新保存的 snapshot，这算个<strong>隐式依赖</strong>，其实风格不太好，在工程实践中尽量避免，或者增加一些详细注释。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_log.go</span></span><br><span class="line"><span class="comment">// isntall snapshot from the leader to the follower</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> installSnapshot(index, term <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        rl.snapLastIdx = index</span><br><span class="line">        rl.snapLastTerm = term</span><br><span class="line">        rl.snapshot = snapshot</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make a new log array</span></span><br><span class="line">        <span class="comment">// just discard all the local log, and use the leader&#x27;s snapshot</span></span><br><span class="line">        newLog := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        newLog = <span class="built_in">append</span>(newLog, LogEntry&#123;</span><br><span class="line">                Term: rl.snapLastTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        rl.tailLog = newLog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower 将 snapshot 保存到<code>rf.log</code> 中时，完全覆盖掉以前日志就可以。因为新来的 snapshot 的最后一条日志下标（ <code>lastIncludeIndex</code> ）一定是大于原来 Follower log 的最后一条 index 的（即 Leader 发过来的 snapshot 肯定包含更多信息），否则 Leader 就不需要发送 snapshot 给 Follower 了。</p>
<h1>应用 <code>snapshot</code></h1>
<p>当 Follower 在 Raft 层持久化以后，还要通过 <code>rf.applyCh</code> 发送到应用层进行 apply。为了保证所有的 apply 串行执行，我们将所有的 apply 逻辑都收束到 <code>applicationTicker</code> 线程中。</p>
<p>为此，我们在 Raft 结构体中新引入一个标记变量 <code>snapPending</code>，当 Follower 收到 snapshot 时，就设置该标记，并且通过 <code>rf.applyCond</code> 唤醒 <code>applicationTicker</code> 进行 apply。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- raft_application.go </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applicationTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.applyCond.Wait()</span><br><span class="line">                entries := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>)</span><br><span class="line">                snapPendingInstall := rf.snapPending</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> !snapPendingInstall &#123;</span><br><span class="line">                        <span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">                                entries = <span class="built_in">append</span>(entries, rf.log.at(i))</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> !snapPendingInstall &#123;</span><br><span class="line">                        <span class="keyword">for</span> i, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">                                rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                                        CommandValid: entry.CommandValid,</span><br><span class="line">                                        Command:      entry.Command,</span><br><span class="line">                                        CommandIndex: rf.lastApplied + <span class="number">1</span> + i, <span class="comment">// must be cautious</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                                SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">                                Snapshot:      rf.log.snapshot,</span><br><span class="line">                                SnapshotIndex: rf.log.snapLastIdx,</span><br><span class="line">                                SnapshotTerm:  rf.log.snapLastTerm,</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> !snapPendingInstall &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Apply log for [%d, %d]&quot;</span>, rf.lastApplied+<span class="number">1</span>, rf.lastApplied+<span class="built_in">len</span>(entries))</span><br><span class="line">                        rf.lastApplied += <span class="built_in">len</span>(entries)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Install Snapshot for [0, %d]&quot;</span>, rf.log.snapLastIdx)</span><br><span class="line">                        rf.lastApplied = rf.log.snapLastIdx</span><br><span class="line">                        <span class="keyword">if</span> rf.commitIndex &lt; rf.lastApplied &#123;</span><br><span class="line">                                rf.commitIndex = rf.lastApplied</span><br><span class="line">                        &#125;</span><br><span class="line">                        rf.snapPending = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 applicationTicker 原来的逻辑是三段式的：</p>
<ol>
<li>临界区（加锁）内，提取要 apply 的数据</li>
<li>临界区外，通过 channel 进行 apply</li>
<li>临界区内，更新相关变量</li>
</ol>
<p>我们新增的 apply snapshot 逻辑也保持这样的三段式，分别增加一段逻辑，并通过 <code>snapPending</code> 进行区分，本次 apply 是 apply log 还是 apply snapshot。</p>
<p>如上述代码标红部分，需要注意的是 apply 了 snapshot 之后，要：</p>
<ol>
<li>更新 <code>commitIndex</code> 和 <code>lastApplied</code> ：避免 apply 到和 snapshot 有交叠的日志</li>
<li>清除 <code>snapPending</code> 标记位：避免重复 apply snapshot</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>21. Raft 的总结和优化</title>
    <url>//b900966.html</url>
    <content><![CDATA[<p>看到这里，恭喜你，已经实现了一个“麻雀虽小、五脏俱全”的基本版本的 Raft（当然，我们没有实现成员变更）。如果你是跟着课程一步步代码敲过来的，想必你会有很多经验、也有很多困惑，欢迎留言跟大家分享。</p>
<h1>整体测试</h1>
<p>针对多线程并发访问的数据竞态测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  raft git:(raft) ✗ go test -run Part -race </span><br><span class="line">Test (PartA): initial election ...</span><br><span class="line">  ... Passed --   3.1  3   94   26978    0</span><br><span class="line">Test (PartA): election after network failure ...</span><br><span class="line">  ... Passed --   4.5  3  184   38101    0</span><br><span class="line">Test (PartA): multiple elections ...</span><br><span class="line">  ... Passed --   5.4  7  972  201839    0</span><br><span class="line">Test (PartB): basic agreement ...</span><br><span class="line">  ... Passed --   0.5  3   22    5616    3</span><br><span class="line">Test (PartB): RPC byte count ...</span><br><span class="line">  ... Passed --   1.8  3   54  115804   11</span><br><span class="line">Test (PartB): test progressive failure of followers ...</span><br><span class="line">  ... Passed --   4.4  3  184   38230    3</span><br><span class="line">Test (PartB): test failure of leaders ...</span><br><span class="line">  ... Passed --   5.0  3  270   61114    3</span><br><span class="line">Test (PartB): agreement after follower reconnects ...</span><br><span class="line">  ... Passed --   3.6  3  120   32157    7</span><br><span class="line">Test (PartB): no agreement if too many followers disconnect ...</span><br><span class="line">  ... Passed --   3.3  5  318   64828    3</span><br><span class="line">Test (PartB): concurrent Start()s ...</span><br><span class="line">  ... Passed --   0.7  3   24    6302    6</span><br><span class="line">Test (PartB): rejoin of partitioned leader ...</span><br><span class="line">  ... Passed --   6.1  3  258   65932    4</span><br><span class="line">Test (PartB): leader backs up quickly over incorrect follower logs ...</span><br><span class="line">  ... Passed --  20.6  5 2517 1956195  102</span><br><span class="line">Test (PartB): RPC counts aren&#x27;t too high ...</span><br><span class="line">  ... Passed --   2.2  3   65   19294   12</span><br><span class="line">Test (PartC): basic persistence ...</span><br><span class="line">  ... Passed --   4.9  3  168   45357    7</span><br><span class="line">Test (PartC): more persistence ...</span><br><span class="line">  ... Passed --  14.7  5 1266  277162   16</span><br><span class="line">Test (PartC): partitioned leader and one follower crash, leader restarts ...</span><br><span class="line">  ... Passed --   1.1  3   41   10873    4</span><br><span class="line">Test (PartC): Figure 8 ...</span><br><span class="line">  ... Passed --  31.2  5 1759  387419   46</span><br><span class="line">Test (PartC): unreliable agreement ...</span><br><span class="line">  ... Passed --   3.8  5  220   80853  246</span><br><span class="line">Test (PartC): Figure 8 (unreliable) ...</span><br><span class="line">  ... Passed --  35.4  5 4664 8256169  251</span><br><span class="line">Test (PartC): churn ...</span><br><span class="line">  ... Passed --  16.3  5 1443  886128   82</span><br><span class="line">Test (PartC): unreliable churn ...</span><br><span class="line">  ... Passed --  16.2  5  954  422659  524</span><br><span class="line">Test (PartD): snapshots basic ...</span><br><span class="line">  ... Passed --   4.9  3  145   53724  229</span><br><span class="line">Test (PartD): install snapshots (disconnect) ...</span><br><span class="line">  ... Passed --  55.2  3 1736  672025  344</span><br><span class="line">Test (PartD): install snapshots (disconnect+unreliable) ...</span><br><span class="line">  ... Passed --  65.0  3 2020  796668  351</span><br><span class="line">Test (PartD): install snapshots (crash) ...</span><br><span class="line">  ... Passed --  71.0  3 2034  713683  308</span><br><span class="line">Test (PartD): install snapshots (unreliable+crash) ...</span><br><span class="line">  ... Passed --  73.9  3 2055  771062  336</span><br><span class="line">Test (PartD): crash and restart all servers ...</span><br><span class="line">  ... Passed --   7.9  3  259   73616   50</span><br><span class="line">Test (PartD): snapshot initialization after crash ...</span><br><span class="line">  ... Passed --   2.4  3   82   22474   14</span><br><span class="line">PASS</span><br><span class="line">ok      course/raft     465.425s</span><br></pre></td></tr></table></figure>
<p>使用测试工具进行多并发的多轮次测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  raft git:(raft) ✗ dstest Part  -p 30 -n 100 </span><br><span class="line"> Verbosity level set to 0</span><br><span class="line">┏━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━┓</span><br><span class="line">┃ Test     ┃ Failed      ┃      Total ┃             Time.       ┃</span><br><span class="line">┡━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━━━━┩</span><br><span class="line">│ Part     │      0      │      100   │        460.74 ± 8.04    │</span><br><span class="line">└──────┴────────┴───────┴───────────────┘</span><br></pre></td></tr></table></figure>
<h1>aft 小结</h1>
<p>Raft 虽然号称是针对 Paxos 的简化版，且面向是面向工程实现的，但在实践过程中仍然有海量的细节。但只要掌握了一些基本的原则和规律，是可以对这些细节进行梳理的。</p>
<p>我们在 [01. Raft 论文解读]一节中已经讲了对 Raft 的感性认识。那么在经过了一遍完整的实现了之后，是时候谈谈一些实践上的经验了。</p>
<h2 id="模块化">模块化</h2>
<p>尽量的相关联的逻辑拆到单独的文件中去：</p>
<ol>
<li><code>raft_election.go</code>：领导选举相关逻辑和 RPC</li>
<li><code>raft_replication.go</code>：日志复制相关的逻辑和 RPC</li>
<li><code>raft_application.go</code>：日志应用 Loop</li>
<li><code>raft_compaction.go</code>：日志压缩相关逻辑和 RPC</li>
<li><code>raft_log.go</code>：底层日志模块，包含 snapshot 和尾部日志</li>
<li><code>raft_persistence.go</code>：序列化和反序列化函数</li>
<li><code>raft.go</code>：Raft 结构体定义和一些公共逻辑</li>
</ol>
<p>模块化就像给代码建“索引”。当你想改哪一块的时候，直接从相关文件中找就可以，如果全部都放 <code>raft.go</code> 中，虽然开始感觉很方便，但随着代码的不断膨胀，之后修改代码时，会有大量的时间花在定位所需逻辑上。</p>
<p>这工业中，这点更为重要，对于动辄数万、数十万的代码，如果没有一定层次的抽象和组织，维护起来简直是灾难。</p>
<p>其他的模块化，或者说抽象化，还有类似 <code>RaftLog</code> 结构体的实现。我们将物理上的 <code>snapshot</code> 和 <code>tailLog</code> 打包在一起，形成一个整体的、看似从零开始的逻辑日志。重构后会发现，所有依赖代码可以进行简单的“平替”，基本不需要做任何逻辑上的修改。这就是通过抽奖，来维持逻辑上的不变性、将大量细节隐藏的一种思想。</p>
<h2 id="RPC-处理">RPC 处理</h2>
<p>一个基本的原则是，我们不能对 RPC args/reply 有没有收到、收到的顺序有任何假设。有没有收到容易处理，但是我们往往会不自觉的对<strong>收到的 Reply 的顺序</strong>有假设。举个例子：</p>
<p>在 PartB 中 Leader 向 Follower 同步日志时，会从 index 较大处向着 index 较小处进行“试探”，且在试探失败时要更新 next 进行下一次试探。在更新 next 时，如果我们的某次先前试探的 reply，后面才到，就很容易造成 next 并不是<strong>单调递减</strong>的，因此要加一个简单判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> prevIndex &lt; rf.nextIndex[peer]  &#123;</span><br><span class="line">        rf.nextIndex[peer] = prevIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这种情况很难测出来，所以即使不加可能大多数情况下也能通过测试。这也正是多线程 + RPC 的难调之处之一。</p>
<p>另外，更常见的，就是处理 RPC reply 前， 先要判断是否还满足 RPC args 发出去前的状态，如果不满足，则该 reply 可以直接废弃掉了。这就好比，在进行状态机转换的时候，要判断自己是否还处于“自己认为的状态”。在单线程中，这是天经地义的，根本不需要思考。但在多线程编程中，要时刻注意维持这种“<strong>不变性</strong>”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check context lost</span></span><br><span class="line"><span class="keyword">if</span> rf.contextLostLocked(Leader, term) &#123;</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Context Lost, T%d:Leader-&gt;T%d:%s&quot;</span>, peer, term, rf.currentTerm, rf.role)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下标处理">下标处理</h2>
<p>对于初学者来说，日志下标处理可以算作最繁琐、易错的事情之一了。尤其是很多时候，往往下标多一个还是少一个不能弄的很清楚。有很多个因素造就了这点：</p>
<ol>
<li>数组下标从零开始</li>
<li>Golang 切片操作上下界问题</li>
<li>是否在开头放一个不包含数据的特殊日志</li>
<li>PartD 中引入 snapshot 之后截断日志的下标转换</li>
</ol>
<p>只能说下标操作的确很繁琐，即使我写了好多年代码，也依然一不留神就犯错，最后还得靠测试来兜底。但也有一些简单的方法，可以避免一些常见错误。</p>
<p><strong>特例法</strong>。当你吃不准某个下标计算时，可以想个边界上的特例，看看代入进去是否符合预期。比如我们在逐个 apply 日志时，由于 <code>rf.lastApplied</code> 不是同步更新的，因此每次 <code>CommandIndex</code> 就得算，这个计算就很容易出错。这时，就可以举个例子，当 <code>i = 0</code> 时，表达式是否正确。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                CommandValid: entry.CommandValid,</span><br><span class="line">                Command:      entry.Command,</span><br><span class="line">                CommandIndex: rf.lastApplied + <span class="number">1</span> + i, <span class="comment">// must be cautious</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>迭代法</strong>。不是每次计算，而是随着外层循环迭代一起迭代，这样只要初始对的上，之后肯定就对的上。其实道理和上面的特例是一样的，不过代码更为直观。如上面的例子，可以改成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmdIdx := rf.lastApplied + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                CommandValid: entry.CommandValid,</span><br><span class="line">                Command:      entry.Command,</span><br><span class="line">                CommandIndex: cmdIdx, <span class="comment">// must be cautious</span></span><br><span class="line">        &#125;</span><br><span class="line">        cmdIdx++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>哨兵法</strong>。比如我们在 PartD 中在 tailLog 的下标为零的位置，放了一个 mock 出来的日志，起到一个“哨兵”作用，且可以避免计算时额外 <code>+/- 1</code> 。如在进行下标转换时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logicIdx = rl.snapLastIdx + tailIdx</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> idx(logicIdx <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// if the logicIdx fall beyond [snapLastIdx, size()-1]</span></span><br><span class="line">        <span class="keyword">if</span> logicIdx &lt; rl.snapLastIdx || logicIdx &gt;= rl.size() &#123;</span><br><span class="line">                <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%d is out of [%d, %d]&quot;</span>, logicIdx, rl.snapLastIdx, rl.size()<span class="number">-1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> logicIdx - rl.snapLastIdx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开头不放这么一个没有实际数据的哨兵，则每次转换要变成：<code>logicIdx - rl.snapLastIdx - 1</code>。</p>
<p>另外一个问题，就是在使用下标前，尽量保证下标在合法区间内，这在对使用 <code>RaftLog.at</code> 时尤为重要。</p>
<h1>可优化点</h1>
<p>无论针对课程，还是在工业实践中，现在的代码都有很多的优化空间。下面随意列举一些：</p>
<ol>
<li><strong>锁粒度变细</strong>。现在是一把大锁保护 Raft 结构体中的所有字段，如果想要吞吐更高的话，需要将锁的粒度进行拆分，将每组常在一块使用的字段单独用锁。</li>
<li><strong>Leader 退出</strong>。如果 Leader 在同步日志时发现大部分节点都<strong>持续</strong>连不上，可以自行退出，因为这时候可能发生了网络隔离，其他节点可能已经自行选出了新的 Leader。</li>
<li><strong>日志并发同步</strong>。现在所有的日志同步都是一股脑的同步过去的，如果日志量特别大，会出现单个 RPC 放不下的问题。此时就要分段发送，最简单的方法就是确认一段之后再发送下一段（类似 TCP 中的停等协议），可以优化成滑动窗口协议，并发的发送和确认。</li>
<li><strong>Leader 收到日之后立即同步</strong>。现在每次 Leader 收到应用层的日志后，都会等待下一个心跳周期才会同步日志。为了加快写入速度，可以在 Leader 收到日志后就立即发送，但要注意 batch，不要每次收到一条就立即发。否则一下收到 100 条日志，就会产生 100 次 RPC。</li>
<li><strong>读优化</strong>。这个增加 KV 层才会涉及。不过工业界常用的优化有 Lease Read，可以分摊 Leader 的读取压力。</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>22 基于 raft 的分布式 KV 概述</title>
    <url>//9167665f.html</url>
    <content><![CDATA[<p>在前面的第一部分的学习中，大家已经对分布式大致理论、分布式共识算法有了基本的认识，并且已经完整的实现了 raft 的各个重要组成部分，学习到了很多关于分布式系统的基本概念以及代码实践。</p>
<p>接下来，就要在实践中更进一步，基于前面实现的 raft 算法，去构建一个高可用的分布式 Key/Value 服务，通过这一部分的学习，你将会真正的将 raft 使用起来，这不仅可以帮助你在更深的维度去理解分布式理论、raft 共识算法，并且让你对生产环境中的高可用、容错的项目有具体的实践经验。</p>
<h2 id="大致架构">大致架构</h2>
<p>我们需要构建的分布式 KV 服务是什么样的架构？</p>
<p>我们的分布式 KV 服务将会是一个复制状态机，由几个使用 raft 进行状态复制的 kv 服务节点组成。分布式 KV 服务需要保证在集群大多数节点正常的情况下依然能够正常提供服务，即使有一些其他的错误或者网络分区。</p>
<p><img src="./assets/22-1.PNG" alt="22-1"></p>
<p>大致的流程是客户端向后端的 servers 发起请求，后端的服务是由多个节点组成的，每个节点之间使用 raft 进行状态复制，客户端会选择将请求发送到 Leader 节点，然后由 Leader 节点进行状态复制，即发送日志，当收到多数的节点成功提交日志的响应之后，Leader 会更新自己的 commitIndex，表示这条日志提交成功，并且 apply 到状态机中，然后返回结果给客户端。</p>
<p>在这一个分布式 KV 部分完成之后，加上前面已经实现了的 raft 部分，我们就基本实现了下图中提到的每一个部分（这个图可能大家在前面的学习中已经看到过了，主要包含了 raft 的一些主要方法的状态转换和基于 raft 的 KV 服务的交互，<a href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf%EF%BC%89%EF%BC%9A">https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf）：</a></p>
<p><img src="./assets/22-2-6165474.PNG" alt="22-2"></p>
<h2 id="代码框架">代码框架</h2>
<p><strong>需要切换到 example 分支！</strong></p>
<p>在我们的课程中，分布式 KV 部分主要是在目录 kvraft 中，大致包含客户端和服务端的逻辑。</p>
<p>客户端是由一个叫 Clerk 的结构体进行表示的，它主要是维护了客户端发送请求到后端 KV 服务的逻辑。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Clerk</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   servers []*labrpc.ClientEnd</span><br><span class="line">   <span class="comment">// You will have to modify this struct.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clerk 会向 KV 服务发送三种类型的请求：</p>
<ul>
<li>Get：通过 key 获取 value</li>
<li>Put：设置 key/value 对</li>
<li>Append：将值追加到 key 对应的 value 上，如果 key 不存在，则相当于 Put</li>
</ul>
<p>需要注意的是我们的 Get/Put/Append 方法需要保证是具有线性一致性的。线性一致性简单来说是要求客户端的修改对后续的请求都是生效的，即其他客户端能够立即看到修改后的结果，而不会因为我们的多副本机制而看到不一样的结果，最终的目的是要我们的 kv 服务对客户端来说看起来“像是只有一个副本”。</p>
<p>服务端的代码主要是在 server.go 中，结构体 KVServer 描述了一个后端的 kv server 节点所维护的状态：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">KVServer</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu      sync.Mutex</span><br><span class="line">   me      int</span><br><span class="line">   rf      *raft.Raft</span><br><span class="line">   applyCh chan raft.ApplyMsg</span><br><span class="line">   dead    int32 <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">   maxraftstate int <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Your definitions here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 KVServer 维护了一个 raft 库中的 Raft 结构体，表示其是一个 raft 集群中的节点，它会通过 raft 提供的功能向其他的 KVServer 同步状态，让整个 raft 集群中的数据保持一致。</p>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html">https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/ss6VV2nARjHhEZVFKg0vrQ">https://mp.weixin.qq.com/s/ss6VV2nARjHhEZVFKg0vrQ</a></p>
<p><a href="https://www.sofastack.tech/projects/sofa-jraft/consistency-raft-jraft/">https://www.sofastack.tech/projects/sofa-jraft/consistency-raft-jraft/</a></p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>23 kvraft Client 端处理</title>
    <url>//5980c7c3.html</url>
    <content><![CDATA[<p>前面一节主要了解了我们基于 raft 实现的分布式 KV 的大致架构和代码框架，从这一节开始就需要开始具体的代码逻辑了，我们首先需要实现的是客户端的逻辑。</p>
<p>上一节中提到了客户端的结构体 Clerk：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Clerk</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   servers []*labrpc.ClientEnd</span><br><span class="line">   <span class="comment">// You will have to modify this struct.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其中维护了 servers 列表，表示的是后端分布式 KV 服务的所有节点信息，我们可以通过这个信息去向指定的节点发送数据读写的请求。</p>
<p>前面提到了三种类型的请求，主要是：</p>
<ul>
<li>Get</li>
<li>Put</li>
<li>Append</li>
</ul>
<p>每个 kv 服务的节点都是一个 raft 的 peer，客户端发送请求到 kv 服务的 Leader 节点，然后 Leader 节点会存储请求日志在本地，然后将日志通过 raft 发送给其他的节点进行状态同步。所以 raft 日志其实存储的是一连串客户端请求，然后 server 节点会按照顺序执行请求，并将结果存储到状态机中。</p>
<p>这里 Clerk 发送请求的时候，由于事先并不知道哪个节点是 Leader，所以只能轮询重试，直到得到了正确的响应。然后我们可以保存一下 Leader 节点的 id，下一次发送请求的时候，就直接从这个节点开始发起请求，省去了轮询寻找 Leader 节点的开销。</p>
<p>Get 方法的处理大致如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">   args := GetArgs&#123;Key: key&#125;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> reply GetReply</span><br><span class="line">      ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">      <span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">         <span class="comment">// 节点id加一，继续重试</span></span><br><span class="line">         ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 请求成功，返回 value</span></span><br><span class="line">      <span class="keyword">return</span> reply.Value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Put 和 Append 的逻辑由于比较类似，所以将其作为一个 RPC 请求，只是加了一个名为 Op 的参数加以区分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line">   args := PutAppendArgs&#123;</span><br><span class="line">      Key:   key,</span><br><span class="line">      Value: value,</span><br><span class="line">      Op:    op,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> reply PutAppendReply</span><br><span class="line">      ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">      <span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">         <span class="comment">// 节点id加一，继续重试</span></span><br><span class="line">         ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 请求成功</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考资料</strong></p>
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html">https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html</a></p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>24 kvraft Server 端处理</title>
    <url>//bee5b142.html</url>
    <content><![CDATA[<p>前面客户端的逻辑比较简单，接下来我们专注于分布式 KV 的服务端的处理，也就是说当客户端的请求发送过来之后，我们的后端的分布式 kv server 应该怎样处理这个请求。</p>
<p><img src="./assets/22-1.PNG" alt="22-1"></p>
<p>按照我们前面梳理的大致交互逻辑，客户端的请求到达之后，我们需要首先通过 raft 模块将其存储到 raft 日志中，回想一下我们在前面实现的 raft 库中，提供了一个 <code>Start</code> 入口方法，这个方法是 raft 接收外部请求的，我们会将请求通过这个方法传递过去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">   rf.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;</span><br><span class="line">      CommandValid: <span class="literal">true</span>,</span><br><span class="line">      Command:      command,</span><br><span class="line">      Term:         rf.currentTerm,</span><br><span class="line">   &#125;)</span><br><span class="line">   LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;Leader accept log [%d]T%d&quot;</span>, <span class="built_in">len</span>(rf.log)<span class="number">-1</span>, rf.currentTerm)</span><br><span class="line">   rf.persistLocked()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span>, rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Start</code> 方法会返回当前的节点是不是 Leader，如果不是的话，我们需要向客户端反馈一个 <code>ErrWrongLeader</code> 错误，客户端获取到之后，发现此节点并不是 Leader，那么会挑选下一个节点重试请求。</p>
<p>当 raft 集群中的 Leader 节点处理了 Start 请求之后，它会向其他的 Follower 节点发送 <code>AppendEntries</code> 消息，将日志同步到其他的 Follower 节点，当大多数的节点都正常处理之后，Leader 会收到消息，然后更新自己的 <code>commitIndex</code>，然后将日志通过 applyCh 这个通道发送过去。</p>
<p><img src="./assets/24-2.PNG" alt="24-2"></p>
<p>然后 kv server 收到 apply 消息之后，将命令应用到本地的状态机中，然后返回给客户端。</p>
<p>也就是说，我们客户端需要一直等待 raft 模块同步完成，并且 Leader 节点将操作应用到状态机之后，才会返回结果给客户端。</p>
<p>所以这里我们需要启动一个后台线程来执行 apply 任务，主要是从 applyCh 中接收来自 raft 的日志消息，处理完之后，将结果存储到一个 channel 中，这时候 Get/Put/Append 方法就能从这个 channel 中获取到结果，并返回给客户端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu      sync.Mutex</span><br><span class="line">   me      <span class="type">int</span></span><br><span class="line">   rf      *raft.Raft</span><br><span class="line">   applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">   dead    <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">   maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Your definitions here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>25 kvraft 的节点故障与重复请求</title>
    <url>//be0b5100.html</url>
    <content><![CDATA[<p>前面一节我们处理了 server 端的大致逻辑，我们知道 kv 服务是由多个 raft 节点组成的，而由于分布式系统中不可避免的节点故障等缘故，我们需要去处理这样的 failure 问题，这样才能够保证我们的分布式系统是始终可用、可靠的，即在大多数节点正常下依然能够正常响应请求，容忍少数节点发生各种未知错误。</p>
<p>例如，如果我们的客户端向集群中的 Leader 发送了一个请求，Leader 接收到请求之后，因为某种原因出现了故障，并且降级为 Follower，这时候客户端便一直等不到回复。直到客户端请求超时，那么它就会向下一个节点重试请求，直到正确得到了 Leader 的回应。</p>
<p><img src="./assets/25-1.PNG" alt="25-1"></p>
<p>因此在客户端的 Clerk 代码中，如果节点发送故障，需要轮询下一个节点，重试客户端请求，直到得到了正确的响应，才结束请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">   <span class="comment">// You will have to modify this function.</span></span><br><span class="line">   args := GetArgs&#123;</span><br><span class="line">      Key: key,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> reply GetReply</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">      <span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">         <span class="comment">// 请求失败，选择另一个节点重试</span></span><br><span class="line">         ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用成功，返回 value</span></span><br><span class="line">      <span class="keyword">return</span> reply.Value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重复请求问题</strong></p>
<p>试想这样一个场景：分布式 KV 有一个客户端，先执行了 Put(x, 1) 请求，将 x 的值设置为 1，接着又执行了 Put(x，2)，将 x 的值设置为了 2。如果 Put(x, 1) 在执行的过程中，对应的节点发生了故障，那么它会重试请求，又将 x 的设置为了 1，那么这便违背了线性一致性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   Client               Client</span><br><span class="line">-------------      ---------------</span><br><span class="line">  Put(x, <span class="number">1</span>)               |</span><br><span class="line">     |                 Put(x, <span class="number">2</span>)</span><br><span class="line">     |                    |</span><br><span class="line">    失败                  成功</span><br><span class="line">     |                    |</span><br><span class="line">    重试                  </span><br><span class="line">     |</span><br><span class="line">  Put(x, <span class="number">1</span>)     </span><br></pre></td></tr></table></figure>
<p>线性一致性要求每个客户端的请求应该立即被执行，并且只被执行一次，对于重试的请求，我们应该如何避免其被执行多次呢？</p>
<p>其实在 raft 论文中已经给出了相应的阐释以及解决方案：</p>
<p><img src="./assets/25-2.PNG" alt="25-2"></p>
<p>一个非常直观的解决办法就是我们给客户端的每个命令赋予一个唯一的标识，当命令执行完之后，将命令标识和执行的结果保存到状态机中的一个 map 里面。每次请求的时候，我们首先从这个 map 中根据唯一标识获取是否存在这个命令，如果存在的话，则说明已经执行过了，则直接返回保存的结果，而不用再发送到 raft 模块进行同步。</p>
<p>只不过这样做有一个重要的前提，那就是客户端默认在同一个时刻只会有一个命令，即一个 Clerk 内部是不会有并发的请求的，这显然是合理的。</p>
<p><img src="./assets/25-3.png" alt="25-3"></p>
<p>还需要注意的一个细节是，我们需要将每个命令都存储到去重的 map 中吗？显然不是，一个客户端只会重试当前最新的这个命令，对于已经成功执行的命令就没必要重试了，因此我们的去重 map 只需要为每一个客户端存储一个当前最新的命令即可。</p>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html">https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html</a></p>
<p><a href="https://pdos.csail.mit.edu/6.824/notes/l-raft-QA.txt">https://pdos.csail.mit.edu/6.824/notes/l-raft-QA.txt</a></p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>26 带snapshot 的 kvraft 实现</title>
    <url>//f45ec3fa.html</url>
    <content><![CDATA[<p>在前面的几个章节中，我们基本实现了分布式 KV 的大致逻辑，构建了一个高可用的分布式 KV 系统。</p>
<p>但是我们并没有使用前面在 raft 库中实现的 <code>Snapshot</code> 方法，这样一来，如果系统重启了，raft 需要加载全量的数据去恢复状态，如果节点中的数据量较大的话，这样会消耗较长的时间去加载。</p>
<p>所以我们可以利用 Snapshot 的功能，对 raft 日志进行压缩，降低日志存储的空间，减少 KVServer 集群在重启时的耗时。</p>
<p>在代码中，KVServer 维护了一个字段名为 <code>maxraftstate</code>，它会由使用者进行设置，表示的是允许的最大的持久化的 raft 的日志大小。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu      sync.Mutex</span><br><span class="line">   me      <span class="type">int</span></span><br><span class="line">   rf      *raft.Raft</span><br><span class="line">   applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">   dead    <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">   maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Your definitions here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个值会在 KVServer 启动的时候被设置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartKVServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *raft.Persister, maxraftstate <span class="type">int</span>)</span></span> *KVServer &#123;</span><br><span class="line">   <span class="comment">// call labgob.Register on structures you want</span></span><br><span class="line">   <span class="comment">// Go&#x27;s RPC library to marshall/unmarshall.</span></span><br><span class="line">   labgob.Register(Op&#123;&#125;)</span><br><span class="line"></span><br><span class="line">   kv := <span class="built_in">new</span>(KVServer)</span><br><span class="line">   kv.me = me</span><br><span class="line">   kv.maxraftstate = maxraftstate</span><br><span class="line"></span><br><span class="line">   <span class="comment">// You may need initialization code here.</span></span><br><span class="line"></span><br><span class="line">   kv.applyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ApplyMsg)</span><br><span class="line">   kv.rf = raft.Make(servers, me, persister, kv.applyCh)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// You may need initialization code here.</span></span><br><span class="line">   kv.dead = <span class="number">0</span></span><br><span class="line">   kv.lastApplied = <span class="number">0</span></span><br><span class="line">   kv.stateMachine = NewMemoryKVStateMachine()</span><br><span class="line">   kv.notifyChans = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> *OpReply)</span><br><span class="line">   kv.duplicateTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]LastOperationInfo)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> kv.applyTask()</span><br><span class="line">   <span class="keyword">return</span> kv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们应该将这个值和 <code>persister.RaftStateSize()</code> 的值进行比较，一旦发现 <code>maxraftstate</code> 超过了其大小，则我们需要调用 raft 模块中的 Snapshot 方法，让 raft 模块进行日志的压缩。如果 <code>maxraftstate</code> 的值是 -1，则说明不需要 snapshot。</p>
<p>注意具体在代码中，我们需要修改三个地方：</p>
<p>一是在 apply 任务的后台线程中进行判断，如果必要的话则调用 Snapshot 方法。</p>
<p>二是对于 applyCh 中传递过来的 Snapshot 消息，我们需要从这个 Snapshot 取出对应的数据，然后恢复状态机。</p>
<p>三是在 KVServer 启动的时候，也需要直接从 Snapshot 中恢复状态。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>27 基于 multi raft 的 shardkv 概述</title>
    <url>//a91a53ed.html</url>
    <content><![CDATA[<p>前面的一个部分，我们完整实现了一个基于 raft，并且满足高可用、线性一致性的分布式 KV 存储系统。</p>
<p>这个新的部分会更进一步，我们会基于 raft 构建一个分片的分布式 KV。</p>
<p>一个分片（shard）指的是一个 Key/Value 数据集的一部分数据，比如，对一个有很多数据的 KV 存储系统中，所有以 ‘a’ 开头的 key 可以是一个分片，所有以 ‘b’ 开头的 key 可以是一个分片，当然这里只是简单举一个 shard 划分的例子，实际上划分数据的办法还有很多，最常见的是 Hash 和 Range。</p>
<p>我们为什么需要对数据进行分区？一个非常重要的原因是因为性能，在不分区的情况下，所有数据的读写请求都会在一个分片中，这在并发量较大的情况下可能存在一定的瓶颈。</p>
<p>如果对数据做了分区，那么不同分区之间的数据读写请求是可以并行的，这能够较大的提升 KV 系统的并发能力。</p>
<h2 id="大致架构">大致架构</h2>
<p>我们这个部分需要完成的分片的分布式 KV 存储系统由两个主要的部分组成。首先是复制组（Replica Group），它指的是处理一个或多个 shard 的 KV 服务，通常是由一个 Raft 集群组成的，所以一个完整的分片分布式 KV 系统中一般存在多个 Replica Group，每个 Group 负责一部分 shard 的读写请求和数据存储，多个 Replica Group 的组合又叫做 <code>multi raft</code>。</p>
<p><img src="./assets/27-1.PNG" alt="27-1"></p>
<p>第二个组成部分是 “shard controller”，它主要是存储系统元数据，一般是一些配置信息，例如每个 Group 应该负责哪些 shard，这个配置信息是有可能发生变化的。客户端首先会从 shard controller 获取请求 key 所属的 Group，并且 Group 也会从 shard controller 中获取它应该负责哪些 shard。shard controller 也一般是会保证高可用，因为如果 shard controller 发生了单点故障，那么整个分布式 KV 系统就不可用了，因此 shard controller 也会使用 raft 进行状态同步。</p>
<p>我们实现的分片分布式系统需要能够将 shard 在不同的 Group 中进行迁移，为什么要这样做？</p>
<p>一个原因是负载均衡，比如一个 Group 有可能比其他的负责了更多 shard 的请求，导致其自身压力较大，因此我们需要将较多 shard 的 Group 移动到其他较少 shard 的 Group 中，让各个 Group 之间能够达到一个相对的均衡状态。</p>
<p>另一个原因是集群的变更，例如一个旧的 Group 有可能因为发生了故障而退出了整个集群，那么它负责的 shard 就应该转移到其他的 Group 中。还有一种情况是集群中加入了新的 Group，那么也需要将一些 shard 移动到这个新的 Group 中。</p>
<p>这一部分最主要的难点和挑战在于处理配置的变更，即 shard 到 Group 的映射关系。在一个 Group 的内部，所有 Group 内部的成员都必须要在处理请求和配置变更同时发生时保持一致。</p>
<p>例如，如果一个 Group 收到了配置变更的消息，指示它不能再负责一个 shard 了，而如果此时刚好有一个 Put 请求到这个 shard 上，那么此时 Group 内所有的副本都应该就 Put 请求应该是在配置变更之前还是之后生效而保持一致。如果是在之前生效的话，那么这个 Put 请求应该生效，并且 shard 新所属的 Group 能够看到这个 Put 的值，如果是之后生效的话，那么 Put 请求不应该成功，客户端需要向 shard 新的所属的 Group 重试请求。</p>
<p><strong>这种情况的一种推荐的解决方案是将配置变更的请求也传到 raft 模块中进行状态同步，需要保证一个 shard 在同一时刻，只能被一个 Group 所负责。</strong></p>
<p>配置变更也需要各个 Group 之间进行数据传输，比如一个 shard 在配置变更期间的所有权转移到了另一个 Group 中，那么一个 Group 就需要从原来的 Group 中获取这个 shard 的所有数据。</p>
<p>我们实现的分片分布式 KV 和生产环境中的分布式存储系统的大致架构是类似的，例如 BigTable、Spanner、HBase、TiKV 等等。但是实际的系统的细节会更加的复杂。</p>
<h2 id="代码框架">代码框架</h2>
<h3 id="shardctrler">shardctrler</h3>
<p>在我们的课程当中，分片分布式 KV 系统的代码会像其架构一样，分为两个部分，一是 shard controller，这部分代码在目录 <code>shardctrler</code> 中。</p>
<p>这部分的大致逻辑和前一部分中实现的分布式 KV 类似，客户端以 Clerk 结构体进行维护：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">   servers []*labrpc.ClientEnd</span><br><span class="line">   <span class="comment">// Your data here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端这边有四个基础的方法 <code>Query、Join、Leave、Move</code>，表示集群配置的变更，shardctrler 需要处理这个变更，然后将配置信息存储起来。</p>
<p>服务端的处理逻辑和前面的分布式 KV 基本类似，并且由于配置信息数据一般会比较少，因此我们甚至不需要实现 snapshot 机制。</p>
<h3 id="shardkv">shardkv</h3>
<p>另一个组成部分是在目录 <code>shardkv</code> 中，这里主要处理的是分布式 KV 的具体逻辑，客户端同样以 Clerk 结构体进行表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">   sm       *shardctrler.Clerk</span><br><span class="line">   config   shardctrler.Config</span><br><span class="line">   make_end <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> *labrpc.ClientEnd</span><br><span class="line">   <span class="comment">// You will have to modify this struct.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Clerk 相较于之前的多了一些额外的信息，包括 shardctrler、配置信息 Config 等。</p>
<p>客户端这边和之前一样，有三个基础的数据操作的方法 Get、Put、Append。</p>
<p>服务端的代码在 server.go 中，代码基础结构的定义和前一部分分布式 KV 比较类似。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardKV <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu           sync.Mutex</span><br><span class="line">   me           <span class="type">int</span></span><br><span class="line">   rf           *raft.Raft</span><br><span class="line">   applyCh      <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">   make_end     <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> *labrpc.ClientEnd</span><br><span class="line">   gid          <span class="type">int</span></span><br><span class="line">   ctrlers      []*labrpc.ClientEnd</span><br><span class="line">   maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Your definitions here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-shard.html">https://pdos.csail.mit.edu/6.824/labs/lab-shard.html</a></p>
<p><a href="https://github.com/pingcap/blog-cn/blob/master/the-design-and-implementation-of-multi-raft.md">https://github.com/pingcap/blog-cn/blob/master/the-design-and-implementation-of-multi-raft.md</a></p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>28 shard controller 的 Client 端处理</title>
    <url>//28b9a3c6.html</url>
    <content><![CDATA[<p>前面一小节我们主要学习了基于 multi raft 的 shardkv 的大致架构和代码框架，从这一节开始就开始具体的实现编码了。</p>
<p>我们首先来处理一下 shard controller，shardctrler 也是一个分布式 KV 服务，这和我们前一个部分实现的分布式 KV 类似，只是其存储的是 shardkv 的一些配置信息。</p>
<p>Shardctrler 存储的配置信息，实际上是多个带编号的配置组合而成的数组，每个配置都有一个唯一的编号（数组下标），配置中存储的是 shard id 到 Group id 的映射关系，以及 Group id 对应的 KVServer。</p>
<p>每次只要有了新的配置产生，就会向数组中新增一个元素。KV 客户端或者服务端可以向 shardctrler 获取最新的或者旧的配置信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardCtrler <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu      sync.Mutex</span><br><span class="line">   me      <span class="type">int</span></span><br><span class="line">   rf      *raft.Raft</span><br><span class="line">   applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Your data here.</span></span><br><span class="line"></span><br><span class="line">   configs []Config <span class="comment">// indexed by config num</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A configuration -- an assignment of shards to groups.</span></span><br><span class="line"><span class="comment">// Please don&#x27;t change this.</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">   Num    <span class="type">int</span>              <span class="comment">// config number</span></span><br><span class="line">   Shards [NShards]<span class="type">int</span>     <span class="comment">// shard -&gt; gid</span></span><br><span class="line">   Groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span> <span class="comment">// gid -&gt; servers[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 shardctrler 的客户端中，提供的方法主要是对配置进行获取，以及配置变更的处理。目前有四个方法：Query、Leave、Join、Move。</p>
<p><code>Join</code> 方法是添加新的 Group，它的参数是一个 map，存储了 Replica Group 的唯一标识 GID 到服务节点名字列表的映射关系。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Join(servers <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span>) &#123;</span><br><span class="line">   args := &amp;JoinArgs&#123;&#125;</span><br><span class="line">   <span class="comment">// Your code here.</span></span><br><span class="line">   args.Servers = servers</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// try each known server.</span></span><br><span class="line">      <span class="keyword">for</span> _, srv := <span class="keyword">range</span> ck.servers &#123;</span><br><span class="line">         <span class="keyword">var</span> reply JoinReply</span><br><span class="line">         ok := srv.Call(<span class="string">&quot;ShardCtrler.Join&quot;</span>, args, &amp;reply)</span><br><span class="line">         <span class="keyword">if</span> ok &amp;&amp; reply.WrongLeader == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Leave</code> 方法的参数是一组集群中的 Group ID，表示这些 Group 退出了分布式集群。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Leave(gids []<span class="type">int</span>) &#123;</span><br><span class="line">   args := &amp;LeaveArgs&#123;&#125;</span><br><span class="line">   <span class="comment">// Your code here.</span></span><br><span class="line">   args.GIDs = gids</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// try each known server.</span></span><br><span class="line">      <span class="keyword">for</span> _, srv := <span class="keyword">range</span> ck.servers &#123;</span><br><span class="line">         <span class="keyword">var</span> reply LeaveReply</span><br><span class="line">         ok := srv.Call(<span class="string">&quot;ShardCtrler.Leave&quot;</span>, args, &amp;reply)</span><br><span class="line">         <span class="keyword">if</span> ok &amp;&amp; reply.WrongLeader == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Move</code> 方法的参数是一个 shard 编号和一个 Group ID。主要是用于将一个 shard 移动到指定的 Group 中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Move(shard <span class="type">int</span>, gid <span class="type">int</span>) &#123;</span><br><span class="line">   args := &amp;MoveArgs&#123;&#125;</span><br><span class="line">   <span class="comment">// Your code here.</span></span><br><span class="line">   args.Shard = shard</span><br><span class="line">   args.GID = gid</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// try each known server.</span></span><br><span class="line">      <span class="keyword">for</span> _, srv := <span class="keyword">range</span> ck.servers &#123;</span><br><span class="line">         <span class="keyword">var</span> reply MoveReply</span><br><span class="line">         ok := srv.Call(<span class="string">&quot;ShardCtrler.Move&quot;</span>, args, &amp;reply)</span><br><span class="line">         <span class="keyword">if</span> ok &amp;&amp; reply.WrongLeader == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Query</code> 方法的参数是一个配置编号，shardctrler 依赖于这个带编号的配置，如果编号是 -1，或者大于已知的最大的编号，那么应该返回最近的一个配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Query(num <span class="type">int</span>) Config &#123;</span><br><span class="line">   args := &amp;QueryArgs&#123;&#125;</span><br><span class="line">   <span class="comment">// Your code here.</span></span><br><span class="line">   args.Num = num</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// try each known server.</span></span><br><span class="line">      <span class="keyword">for</span> _, srv := <span class="keyword">range</span> ck.servers &#123;</span><br><span class="line">         <span class="keyword">var</span> reply QueryReply</span><br><span class="line">         ok := srv.Call(<span class="string">&quot;ShardCtrler.Query&quot;</span>, args, &amp;reply)</span><br><span class="line">         <span class="keyword">if</span> ok &amp;&amp; reply.WrongLeader == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reply.Config</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉了这几个方法之后，我们应该怎么处理呢？</p>
<p>实际上和前面的分布式 KV 部分的逻辑比较类似，我们在向客户端发送请求的时候，一是需要注意如果发生了一些错误，例如得到了 ErrWrongLeader 或 ErrTimeout 错误，说明当前节点并不是 Leader 或者发生了其他的错误，我们就需要选择另一个节点重试请求。</p>
<p>二是我们仍然需要像之前一样处理重复请求，保证线性一致性，处理的方法和之前一样，给每个客户端的请求都赋予一个维护的标识符，然后在 server 端进行去重。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>29 shard controller 的 Server 端处理</title>
    <url>//4f052246.html</url>
    <content><![CDATA[<p>上一节我们主要处理了 shardkv 中的 shardctrler 的客户端逻辑，这一节我们处理一下 shardctrler 的服务端的逻辑。</p>
<p>其实 Server 这边的处理和前一个部分我们实现的分布式 KV 的 Server 非常类似，逻辑基本上是差不多的。</p>
<p>我们依然需要维护状态机、通知 channel、去重的哈希表，在前面的概述中提到了，由于 shardctrler 是存储的一些配置信息，并不会存储用户数据，所以数据相对来说是比较少的，因此我们可以不用去实现分布式 KV 中的 snapshot 机制。</p>
<p>这里我们接收客户端的四种请求 Query、Join、Leave、Move，然后将其通过 raft 模块进行各个节点之间的状态同步。</p>
<p>然后我们在后台的 apply 线程中处理 raft 已经 commit 的数据，主要是将操作应用到状态机中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> applyLogToStateMachine(op Op) *OpRelpy &#123;</span><br><span class="line">   <span class="keyword">var</span> err Err</span><br><span class="line">   <span class="keyword">var</span> config Config</span><br><span class="line">   <span class="keyword">switch</span> op.OpType &#123;</span><br><span class="line">   <span class="keyword">case</span> OpJoin:</span><br><span class="line">      err = sc.stateMachine.Join(op.Servers)</span><br><span class="line">   <span class="keyword">case</span> OpLeave:</span><br><span class="line">      err = sc.stateMachine.Leave(op.GIDs)</span><br><span class="line">   <span class="keyword">case</span> OpMove:</span><br><span class="line">      err = sc.stateMachine.Move(op.Shard, op.GID)</span><br><span class="line">   <span class="keyword">case</span> OpQuery:</span><br><span class="line">      config, err = sc.stateMachine.Query(op.Num)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;OpRelpy&#123;ControllerConfig: config, Err: err&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>31 shardkv 单 Group 逻辑</title>
    <url>//656a341b.html</url>
    <content><![CDATA[<p>前面几节我们主要实现了分片分布式 KV 中的第一个重要的组成部分，那就是 shard controller，并且实现了获取和更改配置的接口。</p>
<p>接下来我们就需要回归到 shardkv 的具体逻辑了，这里贴一下我们的整体架构图，简单回顾一下：</p>
<p><img src="./assets/31-1.PNG" alt="31-1"></p>
<p>我们的 shardkv 是由多个 Replica Group 组成的，每个 Replica Group 又是由一个 raft 集群组成，使用 raft 共识算法保证数据的一致性。每个 Group 都负责了一部分 shard 的读写请求，全部的 Group 组合到一起，就是一个完整的 shardkv 服务。</p>
<p>Shardctrler 负责存储配置信息，主要是 shard 到 Group 的分配关系，当配置发生变化的时候，Group 应该根据配置处理 shard，并且这里需要保证在处理配置变更时，客户端不能看到不一致的结果。</p>
<p>客户端会通过 Get、Put、Append 这三个方法来访问 shardkv，需要保证 Put 成功之后的结果对于后续的请求是可见的，即使 Put 请求和配置变更同时发生。</p>
<p>首先我们可以处理一种最简单的情况，即集群中只有一个 Group 的情况。</p>
<p><img src="./assets/31-2.PNG" alt="31-2"></p>
<p>在官方 Lab4 的提示中其实也说明了，单个 Group 的逻辑和我们在 Lab3 实现的分布式 KV 基本上是一样的，因为每个 shard 都在这个 Group 中，并不会涉及到 shard 的负载均衡。</p>
<p>所以我们可以直接参考 Lab3 的代码，实现最简单的一个版本，只不过这里我们需要修改一些逻辑，服务端需要判断 key 所属的 shard 是否在对应的 Group 中，如果不是的话则返回一个 ErrWrongGroup 错误。Clerk 中如果拿到了这个 <code>ErrWrongGroup</code> 这个错误，需要重新从 shardctrler 获取配置，然后重试请求。</p>
<p><strong>参考链接</strong></p>
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-shard.html">https://pdos.csail.mit.edu/6.824/labs/lab-shard.html</a></p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>30 shard controller 的状态机处理</title>
    <url>//c6b36fdf.html</url>
    <content><![CDATA[<p>前面一节我们主要对 shardctrler 的服务端进行了处理，主要沿用了之前分布式 KV 的一部分代码，并且由于 shard ctrler 数据量较少，我们也不需要 snapshot 的逻辑。</p>
<p>当 raft 模块状态同步完成之后，节点会发送已经 commit 的日志，我们就会在后台常驻的 apply 线程中进行处理，主要是将用户的操作持久化到状态机中，这一节就来看看状态机中具体的操作逻辑是什么样的。</p>
<p>前面其实提到了我们有四个客户端的方法，分别是 <code>Query、Join、Leave、Move</code>，实际上状态机的处理，就是对这几种方法进行处理，将处理完成之后的配置存储起来，供外部调用，接下来就依次看看这几个方法的大致处理逻辑。</p>
<h2 id="Query">Query</h2>
<p><code>Query</code> 的逻辑比较简单，是通过配置编号 num 进行查询，我们会在状态机中维护一个配置数组，num 其实就是数组的下标，所以能够直接获取到下标对应的配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CtrlerStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">   Configs []Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Join">Join</h2>
<p><code>Join</code> 主要是添加一个 Group 到集群中，我们需要处理添加完成之后的负载均衡问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Join 加入新的复制组，需要处理加入后的负载均衡问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *CtrlerStateMachine)</span></span> Join(groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span>) Err &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们已经知道了 Config 的具体内容，主要包含配置编号 Num、shard 到 gid 的映射、gid 及其对应的节点信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Config A configuration -- an assignment of shards to groups.</span></span><br><span class="line"><span class="comment">// Please don&#x27;t change this.</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">   Num    <span class="type">int</span>              <span class="comment">// config number</span></span><br><span class="line">   Shards [NShards]<span class="type">int</span>     <span class="comment">// shard -&gt; gid</span></span><br><span class="line">   Groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span> <span class="comment">// gid -&gt; servers[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当新添加 Group 的时候，我们这里的参数是 Groups，表示有可能是多个 Group 加入进来。</p>
<p>首先我们需要遍历传递进来的 Group，将其加入到 Config 的 <code>Groups</code> 中，这里就需要注意我们前面提到过的问题，那就是加入之后，shard 应该怎么处理。</p>
<p>假设这样一种情况，我们有 10 个 shard 和 3 个 Group，其在 Config 中的对应关系如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Config.Shards 数组:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> -- shard id</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> -- group id</span><br></pre></td></tr></table></figure>
<p>现在有了一个新的 Group ID 为 4 加入进来，我们就需要重新处理 shard 到 Group 的关系，因为不能让新加入的 Group 处于空闲状态，而应该分担一部分 shard，让整个集群重新达到平衡。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Config.Shards 数组:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>            -- shard id</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span>          -- group id</span><br></pre></td></tr></table></figure>
<p>我们的做法简单来说是从拥有最多 shard 的 Group 中取出一个 shard，将其分配给最少 shard 的那个 Group，如果最多和最少的 shard 的差值小于等于 1，那么说明就已经达到了平衡，否则的话就按照同样的方法一直重复移动 shard。</p>
<p>首先我们将 gid 到 shard 做一个简单的映射，主要是从 Config 的 shards 数组中获取：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shard gid</span></span><br><span class="line"><span class="comment">//   0    1</span></span><br><span class="line"><span class="comment">//   1    1</span></span><br><span class="line"><span class="comment">//   2    2</span></span><br><span class="line"><span class="comment">//   3    2</span></span><br><span class="line"><span class="comment">//   4    1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [0, 1, 4]</span></span><br><span class="line"><span class="comment">//   2     [2, 3]</span></span><br></pre></td></tr></table></figure>
<p>这样我们就得到了每个 gid 对应负责的 shard id。</p>
<p>然后进行前面所说的移动，这里是一个简单的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [0, 1, 4, 8]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"><span class="comment">//   4    []</span></span><br><span class="line"></span><br><span class="line">-- 第一次遍历，shard 最多的是 gid <span class="number">1</span>，最少的是新加入的 gid <span class="number">4</span>，所以移动一个到 gid <span class="number">4</span></span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [1, 4, 8]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"><span class="comment">//   4    [0]</span></span><br><span class="line"></span><br><span class="line">-- 第二次遍历，shard 最多的是 gid <span class="number">1</span>，最少的是 gid <span class="number">4</span>，所以移动一个到 gid <span class="number">4</span></span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [4, 8]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"><span class="comment">//   4    [0, 1]</span></span><br><span class="line"></span><br><span class="line">-- 第三次遍历，shard 最多的是 gid <span class="number">2</span>，最少的是 gid <span class="number">1</span>，其差值等于 <span class="number">1</span>，所以结束移动，集群达到平衡</span><br></pre></td></tr></table></figure>
<p>这样移动完成之后，需要将 gid-&gt;shard id 的映射关系，重新写入到 Config 的 shards 数组中，然后存储起来。</p>
<h2 id="Leave">Leave</h2>
<p><code>Leave</code>方法是将一个或多个 Group 从集群中删除，和 Join 一样，在删除掉集群中的 Group 之后，其负责的 shard 应该转移到其他的 Group 中，重新让集群达到均衡。</p>
<p>处理的逻辑和 Join 类似，首先我们将 gid 进行遍历，并将其从 Config 的 <code>Groups</code> 中删除，并且记录这些被删除的 gid 所对应的 shard，然后将这些 shard 分配给拥有最少 shard 的 Group。</p>
<p>这里举一个简单的例子。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [4, 8]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"><span class="comment">//   4    [0, 1] </span></span><br><span class="line"></span><br><span class="line">-- gid <span class="number">4</span> 离开集群之后，shard <span class="number">0</span> 和 <span class="number">1</span> 就需要重新分配</span><br><span class="line"></span><br><span class="line">-- 第一次遍历，找到拥有 shard 数最少的 gid <span class="number">1</span> 并分配</span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [4, 8, 0]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"></span><br><span class="line">-- 第二次遍历，找到拥有 shard 数最少的 gid <span class="number">1</span> 并分配</span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [4, 8, 0, 1]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br></pre></td></tr></table></figure>
<p>这样集群就重新达到了平衡状态，然后和 Join 一样，重新构造 Config 中的 shards 对应关系，并将其存储起来。</p>
<h2 id="Move">Move</h2>
<p><code>Move</code> 方法的参数是一个 shard id 和 gid，表示将这个 shard 移动的指定的 gid 之上，在这里我们的处理比较简单，因为 Config 中的 shards 关系都是明确的，只需要将 shard id 的 gid 重置为传进来的新的 gid 即可。</p>
<p>以上部分处理完成之后，我们在状态机中的逻辑就完成了，这里可能很多人有一个疑问，那就是 Group 的 Join、Leave 只是将配置变更了，具体移动 shard 的操作应该是在哪里完成呢？</p>
<p>实际上这个是第二部分 shardkv 需要做的事情，shardkv 当中拿到配置之后，如果发现了不同，则需要处理 shard 在不同的 Group 之间的转移。</p>
<p>所以这一部分我们下一节才开始讲述，到这一节整个 shard controller 的功能便完成了，我们实现了一个高可用的分布式 KV，用于存储 shardkv 的配置信息，并且提供了几个简单的接口来处理和查询配置。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>32 shardkv 配置变更</title>
    <url>//cf40ca3f.html</url>
    <content><![CDATA[<p>前面一节我们处理了单个 Group 的逻辑，其实比较简单，和我们前面在 Lab3 实现的分布式 KV 是基本类似的。</p>
<p>今天这一节来处理下配置变更的问题。</p>
<p>shardkv 需要定时从 shardctrler 这边拉取最新的配置，然后根据配置来确定哪些 shard 应该是需要进行迁移的。</p>
<p>上一节我们已经写了一个简单的拉取配置的后台任务，但是按照 lab 的提示，我们每次只能够拉取一个配置，并且按照顺序处理，这样做的目的主要是为了避免覆盖还未完成的配置变更任务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> fetchConfigTask() &#123;</span><br><span class="line">   <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">      kv.mu.Lock()</span><br><span class="line">      newConfig := kv.mck.Query(kv.currentConfig.Num + <span class="number">1</span>)</span><br><span class="line">      kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 传入 raft 模块进行同步</span></span><br><span class="line">      kv.ConfigCommand(RaftCommand&#123;ConfigChange, newConfig&#125;, &amp;OpReply&#123;&#125;)</span><br><span class="line">      time.Sleep(FetchConfigInterval)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拉取完毕配置之后，我们需要构造一个对应的命令，然后传到 raft 模块进行同步。</p>
<p>这里需要做一点小的改造，因为我们之前传入到 raft 的都是客户端的操作，这里我们需要加上配置变更的操作。并且在 apply 协程中进行反解析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> opReply *OpReply</span><br><span class="line">raftCommand := message.Command.(RaftCommand)</span><br><span class="line"><span class="keyword">if</span> raftCommand.CmdType == ClientOpeartion &#123;</span><br><span class="line">   <span class="comment">// 取出用户的操作信息</span></span><br><span class="line">   op := raftCommand.Data.(Op)</span><br><span class="line">   <span class="keyword">if</span> op.OpType != OpGet &amp;&amp; kv.requestDuplicated(op.ClientId, op.SeqId) &#123;</span><br><span class="line">      opReply = kv.duplicateTable[op.ClientId].Reply</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将操作应用状态机中</span></span><br><span class="line">      shardId := key2shard(op.Key)</span><br><span class="line">      opReply = kv.applyToStateMachine(op, shardId)</span><br><span class="line">      <span class="keyword">if</span> op.OpType != OpGet &#123;</span><br><span class="line">         kv.duplicateTable[op.ClientId] = LastOperationInfo&#123;</span><br><span class="line">            SeqId: op.SeqId,</span><br><span class="line">            Reply: opReply,</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   opReply = kv.handleConfigChangeMessage(raftCommand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据最新状态的 Config 信息，我们能够判断出当前 Group 中负责哪些 shard，也能够判断出某个 shard 转移到当前 shard 中。</p>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>33 shardkv 分片迁移</title>
    <url>//6794c952.html</url>
    <content><![CDATA[<p>前面一节我们处理了配置变更的需求，主要是定时从 shardctrler 中拉取配置，我们对传入 raft 模块的结构体进行了一些改造，使其能够兼容两种不同类型的请求，分别是用户操作和配置变更。</p>
<p>用户操作和之前的一样，并没有任何的变化，只是反解析结构体的时候需要注意。</p>
<p>配置变更的操作，上一节主要是简单处理了一下，主要的 shard 迁移流程需要我们继续完善。</p>
<p>在商讨 shard 迁移的具体流程之前，我们可以来简单看一下官方 <a href="https://pdos.csail.mit.edu/6.824/labs/lab-shard.html">lab4</a> 给出的一些提示：</p>
<ul>
<li>在 KVServer 中添加定期从 shardctrler 拉取配置的代码，并且如果客户端请求的 shard 不属于当前 Group，那么应该返回 <code>ErrWrongGroup</code> 错误。这个加上之后，应该仍然能通过第一个测试。</li>
<li>确保 KVServer 中的 Get、Put、Append 方法和配置变更同时发生时，需要有一致的行为。</li>
<li>一次处理一个配置变更的请求，并且按照顺序。</li>
<li>需要在 shard 迁移期间，确保对重复请求的过滤，保证线性一致性。</li>
<li>在一个 shard 迁移到新的 Group 之后，原来的 Group 可以继续持有并不属于它的旧的 shard，目前这样可以简化我们的实现。但是下一节我们会处理这种情况。</li>
<li>你可以直接将整个 map 结构放到 RPC 请求或者回复里，这能够让代码实现更加简洁。</li>
<li>在不同的 Group 之间发送 shard 数据的时候，一般不会持有 map 的锁，例如数据发送到了另一个 Group，但是当前 Group 又要修改这个 shard 的数据，那么就会产生竞态条件。一种解决方案是传输 map 结构的时候将其拷贝一份。</li>
<li>在配置变更期间，在一些 Group 之间可能需要双向传递 shard，如果发生了死锁，可能需要检查这个条件。</li>
</ul>
<p>了解了这些之后，我们再来商讨一下 shard 迁移的解决方案。</p>
<h2 id="简单方案">简单方案</h2>
<p>我们会启动一个后台线程（<code>fetchConfigTask</code>），定期从 shardctrler 拉取配置，拿到这个配置之后，就需要构造一个配置变更的命令，然后传入到 raft 模块中进行状态的同步。</p>
<p>Raft 状态同步完成后，我们会在一个后台 apply 协程中处理 raft 传递过来的结果。</p>
<p>这里我们需要判断请求的类型，如果是用户操作的请求，则和之前一样，应用到状态机即可。</p>
<p>如果是配置变更的请求，我们就需要处理是否有 shard 迁移的情况，比如我们在新配置中发现某个 shard 需要迁移过来，那么我们就可以拉取这个 shard 的数据，然后保存到当前 Group 中。</p>
<p>但是这里有一个问题，那就是 shard 的迁移可能需要较长的时间，因为这涉及到从其他的 Group 中去拉取 shard 数据（网络 IO），这时候我们的 apply 协程就会一直阻塞，直到这个请求处理完成。</p>
<p>由于客户端的用户操作也会经过 apply 协程处理，所以如果此时有客户端的请求到来，那么也只能阻塞等待，那些未参与此次配置变更的 shard 也不能继续提供服务。</p>
<p>还有一个问题是，假如我们分别需要从 G1 和 G2 拉取一个 shard，如果 G1 的拉取成功了，但是 G2 因为故障，我们并没有拉取成功。那么我们从 G1 拉取到的 shard 是否应该正常响应客户端的请求呢？</p>
<p>在 Lab 4 的 challenge 2 中，对这种情况进行了描述。</p>
<p>Challenge 2 要求我们在处理配置变更的时候，如果是未参与的 shard，需要继续提供对客户端的服务，而不是也和其他 shard 一样等待配置变更完成后才恢复服务。</p>
<p>Challenge 2 还要求我们注意，即便是整体的配置变更未完成，只要 shard 已经迁移过来，则可以立即开始提供服务，而不用等待配置变更全部完成。</p>
<p>针对上述的这两种情况，我们就需要调整上面这个简单的方案。</p>
<h2 id="目前方案">目前方案</h2>
<p>前面我们已经了解到，既然每个 shard 在配置变更的时候，可以是独立的，比如一个 Group 中有的 shard 受到了配置变更的影响，而有的并没有受到。而且只要一个 shard 完成了迁移，就需要立即提供服务，不用等待所有的配置变更完成。</p>
<p>根据这样的特征，我们可以给每个 shard 加上一个状态的标识，分别有下面这几种状态</p>
<ul>
<li>Normal</li>
<li>MoveIn</li>
<li>MoveOut</li>
<li>GC</li>
</ul>
<p>结合这个状态，下面是一个 Shard 迁移的流程示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">G1 <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">G2 <span class="number">2</span> <span class="number">6</span></span><br><span class="line">G3 <span class="number">4</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">配置变更，shard <span class="number">5</span> 从 G1 -&gt; G3</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">后台线程拉取配置，更新 shard 状态</span><br><span class="line">G1   <span class="number">5</span></span><br><span class="line">   MoveOut</span><br><span class="line"></span><br><span class="line">G3   <span class="number">5</span></span><br><span class="line">   MoveIn</span><br><span class="line">-------</span><br><span class="line">后台 shard 迁移线程定期执行</span><br><span class="line"></span><br><span class="line">G3：检测到 <span class="number">5</span> 处于 MoveIn 状态，则从原所属 Group 中获取到该 shard 的数据，然后通过 raft 模块进行同步</span><br><span class="line">-------</span><br><span class="line">在 apply 协程中获取到 shard 迁移的请求，则将 shard 的数据插入到当前 Group 中</span><br><span class="line">并且将当前 shard 的状态置为 GC</span><br><span class="line"></span><br><span class="line">G3   <span class="number">5</span></span><br><span class="line">     GC</span><br><span class="line">此时 shard <span class="number">5</span> 已经可以正常提供服务了</span><br></pre></td></tr></table></figure>
<h2 id="改动点">改动点</h2>
<ol>
<li>配置变更的任务只修改 shard 状态，不进行实际的 shard 迁移操作</li>
<li>新增 shard 迁移的后台线程，定期执行 shard 的迁移</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>35 shardkv 补充修改</title>
    <url>//a883a665.html</url>
    <content><![CDATA[<p>在 shardkv 的分片迁移和清理大致完成之后，我们还需要修改几个地方，才能够将测试 run 起来。</p>
<p>主要有以下改动：</p>
<ol>
<li><code>matchGroup</code> 方法，需要判断 shard 的状态，如果是 GC 或者 Normal 状态，均可以继续提供服务</li>
<li><code>StartServer</code> 方法中，需要注册 labgob 相关的结构体。</li>
<li><code>makeSnapshot</code> 和 <code>restoreFromSnapshot</code> 中， config 信息也需要进行持久化，并且需要初始化 shard 的状态</li>
<li>fetchConfigTask 中，需要加上一个判断，如果任何一个 shard 的状态是非 Normal 的，则说明前一个 shard 迁移的流程还在进行中，我们就跳过拉取新的配置，避免覆盖之前的任务</li>
<li>Apply 的时候，客户端操作也需要判断 Group 是否匹配</li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>34 shardkv 分片清理</title>
    <url>//cd6a3100.html</url>
    <content><![CDATA[<p>前面一节我们主要处理了 shardkv 分片迁移的主要流程，配置变更时更改 shard 的状态，并且启动一个后台线程，定期获取 shard 的状态，执行实际的 shard 迁移。</p>
<p>Shard 有四种状态：</p>
<ul>
<li>Normal</li>
<li>MoveIn</li>
<li>MoveOut</li>
<li>GC</li>
</ul>
<p>在前面的实现中，如果一个 shard 已经从 Group 迁移出去了，这个 shard 还会在这个 Group 中存在，并且数据也会继续保留。</p>
<p>但实际上，因为 shard 已经完全迁移到了另一个 Group 中，所以这个 shard 在原 Group 中已经可以不用继续保留了，我们可以将其删除掉。</p>
<p>在 lab4 的 challenge 1 中，要求我们及时清理 Group 中已经无效的 shard，这样能够及时释放空间。</p>
<p>在上一节 shard 迁移的流程中，如果一个 shard 已经完成了迁移，我们会将其置为 GC 状态，所以我们可以启动一个后台线程，定时获取需要执行 GC 的 shard。</p>
<p>拿到这些 shard 之后，我们需要做两件事情，一是给旧的 Group 发送消息，删除对应的 shard；二是给当前 Group 的 shard 发送消息，将其状态从 GC 更改为 Normal。</p>
<p>以下是一个 Shard 清理的大致流程示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">G1 <span class="number">1</span>     <span class="number">3</span>      <span class="number">5</span></span><br><span class="line">              MoveOut</span><br><span class="line">G2 <span class="number">2</span>     <span class="number">6</span></span><br><span class="line">G3 <span class="number">4</span>     <span class="number">7</span>      <span class="number">5</span></span><br><span class="line">                GC</span><br><span class="line"></span><br><span class="line">后台线程拉取所有状态为 GC 的 shard</span><br><span class="line"></span><br><span class="line">发送 RPC 消息：</span><br><span class="line"></span><br><span class="line">之前的 G1 收到消息：将 shard 删除</span><br><span class="line">现在的 G3 收到消息：将 shard <span class="number">5</span> 的状态设置为 Normal，即变更为正常状态</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>36 附录1. 并发编程</title>
    <url>//f97d814d.html</url>
    <content><![CDATA[<p>Raft 通常是是一个多机、多线程的库（lib），因此会涉及大量并发编程知识。 由于在语言层面内置 goroutine 和 channel，Golang 大大简化了并发编程复杂度，这也是课程选择 golang 为编程语言的主要原因。</p>
<h1>Goroutine</h1>
<p>goroutine 是一种<strong>轻量级</strong>线程，是 go runtime 提供的一种用户态线程，因此也被称为协程。所谓轻量，就是相比操作系统线程，每个 goroutine 耗费的资源更少、goroutine 间切换耗费也更低（不会陷入内核态），因此可以有更高的并发度。因此，我们在 golang 中，可以相对随意的创建新的 goroutine。</p>
<p>但我们在决定是否使用 goroutine 时，仍然有一些原则和技巧可以遵循。原则上来说，使用 goroutine 的目的主要有两种：</p>
<ol>
<li><strong>提升计算性能</strong>：主要针对计算密集型任务，多开 goroutine，充分利用现代计算机多核性能。</li>
<li><strong>旁路 IO 负载</strong>：主要针对有 IO 型任务的负载，比如 RPC 和文件 IO，将其放到单独 goroutine 中，避免影响主干工作流性能。</li>
</ol>
<p>对于 raft 来说，主要后面一种情况：即将发送给每个 Peer 的 RPC 放进单独的 goroutine，从而避免阻塞主干 loop（包括 electionLoop 和 replcationLoop）。</p>
<h1>难点</h1>
<p>即便 golang 已经十分友好，作为新手，初次接触并发编程，仍会有诸多困惑之处。原因有很多：</p>
<p><strong>语句失去相对顺序</strong>。编译阶段即使发生了指令重排，也仍然能保证单个线程内语句<strong>执行顺序</strong>和<strong>书写顺序</strong>的<strong>结果</strong>上的一致性。但是多线程间语句的相对顺序，就没有任何保证了。举个<a href="https://go.dev/ref/mem">例子</a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> f()</span><br><span class="line">        g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>g()</code> 最终可能会先输出 <code>2</code> 再输出 <code>0</code> 。而想让多线程间的代码执行保持某种顺序，就必须要使用一些通信手段，强化 happens-before 关系，在 golang 中，这些手段有：</p>
<ol>
<li><code>sync.Mutex</code></li>
<li><code>chan</code></li>
<li><code>sync.Cond</code></li>
</ol>
<p><strong>内存模型难理解</strong>。</p>
<p>TODO</p>
<h1>用锁</h1>
<h2 id="锁的原理">锁的原理</h2>
<p>锁主要用在两种情况下，<strong>可见性</strong>和<strong>原子性</strong>。</p>
<p><strong>可见性</strong>：<strong>让一个线程对共享变量的修改，能及时为其他线程看到</strong>。这主要是因为，线程修改变量时会首先写到自己线程中的缓存中，而我们不能决定缓存数据会什么时候同步到主存中。使用锁，可以让修改立即同步到主存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> rf.currentTerm, rf.role == Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是保证其他线程在取用 term 和 role 的时候，能及时将其他线程的修改结果同步过来。</p>
<p><strong>原子性</strong>：<strong>将一段代码进行打包执行，执行时，不会乱入其他代码</strong>。这样能保证一个逻辑单元正确的执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bank)</span></span> transfer() &#123;</span><br><span class="line">    b.mu.Lock();</span><br><span class="line">    <span class="keyword">defer</span> b.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    b.account1 -= <span class="number">50</span>;   </span><br><span class="line">    b.account2 += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最典型的就是银行转账场景，如果还有个线程在动 <code>b.account1 </code>，比如正在计算发放的利息，如果和本函数交错执行，就会产生错误结果。这种保证和<a href="https://ddia.qtmuniao.com/#/ch07">数据库中的事务</a>对原子性的保证在理念上是一样的。</p>
<h2 id="用锁技巧">用锁技巧</h2>
<p>但在编程中使用锁时，要想用对锁，又是另外一回事。这需要一些实战技巧：</p>
<ol>
<li>空间上：锁的保护范围</li>
<li>时间上：锁的释放时机</li>
</ol>
<h3 id="保护范围">保护范围</h3>
<p>锁的保护范围，即锁所要保护的<strong>共享变量集</strong>。只有明确了锁保护哪些共享变量，我们才能在访问、修改这些共享变量时加对锁。锁的保护范围越大，实现就越容易，但性能就越差；锁的保护粒度越细，性能就会变好（当然过犹不及，锁太多性能也并不见得好，锁本身也会消耗很多资源），但用对就越难（很容易发生死锁）。</p>
<p>因此，用锁的一个基本策略是——<strong>渐进式加锁</strong>。即，对于一个类来说，先用一把大锁保护所有需要共享的字段，保证逻辑正确。在实现正确之后，定位性能瓶颈，按需拆锁——让每个锁只保护少量字段。对于我们的 raft 实验来说，整个 Raft 类使用一把大锁足以。但在工业界中的 raft 实现，会用多把锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">    peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">    persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">    me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">    dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">    mu        sync.Mutex</span><br><span class="line">    <span class="comment">// fields below should be persisted</span></span><br><span class="line">    currentTerm <span class="type">int</span></span><br><span class="line">    votedFor    <span class="type">int</span></span><br><span class="line">    log         []LogEntry</span><br><span class="line"></span><br><span class="line">    <span class="comment">// control apply progress</span></span><br><span class="line">    commitIndex <span class="type">int</span></span><br><span class="line">    lastApplied <span class="type">int</span></span><br><span class="line">    applyCond   *sync.Cond</span><br><span class="line">    applyCh     <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// only for leaders</span></span><br><span class="line">    nextIndex  []<span class="type">int</span> <span class="comment">// guess when initialize</span></span><br><span class="line">    matchIndex []<span class="type">int</span> <span class="comment">// truth from the rpc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer and role</span></span><br><span class="line">    electTimerStart time.Time</span><br><span class="line">    role            Role</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个小技巧就是，在写代码时，<strong>将所有锁需要保护的字段置于锁之后，所有不需要保护的字段置于锁之前</strong>，如上图。但也有例外，比如 <code>applyCh</code> 就是线程安全的，本不需要锁保护，但为了保证字段间的<strong>亲和性</strong>（这是保持代码块清楚的一个重原则），还是把它放到了和其他控制 apply 的字段一块。</p>
<h3 id="释放时机">释放时机</h3>
<p>最简单的加锁方式，就是在所有用到共享变量的函数中，全函数加锁。但这会性能很差，尤其是遇到一些长耗时函数，如果一直不释放锁，其他线程就不能获取锁而执行，使得使用多线程丧失了意义。</p>
<p>于是我们的思路可以改为，一开始全函数上锁，然后寻找函数中的长耗时区域，及时释放锁，耗时区域执行完之后再加回来。这些耗时区域包括：</p>
<ol>
<li>IO：包括本机磁盘 IO 和网络 IO</li>
<li>Channel：尤其是阻塞 channel</li>
</ol>
<p>具体到 raft 中有：</p>
<ol>
<li>网络IO：发送 RequestVote、AppendEntries 的 PRC 请求时</li>
<li>本机IO：读写文件时，比如写日志到外存</li>
<li>Channel：往 Apply Channel 中发送数据</li>
</ol>
<p>当然，最主要的就是发送两个 RPC ，进行选举要票和日志同步时，一定要注意释放锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ----- section 1: construct args-----</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line">nextIndex := rf.nextIndex[server]</span><br><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">        Term:         leaderTerm,</span><br><span class="line">        LeaderId:     rf.me,</span><br><span class="line">        PrevLogIndex: nextIndex - <span class="number">1</span>,</span><br><span class="line">        PrevLogTerm:  rf.log[nextIndex<span class="number">-1</span>].Term,</span><br><span class="line">        Entries:      rf.log[nextIndex:],</span><br><span class="line">        LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----- section 2: send rpc --------</span></span><br><span class="line">reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">ok := rf.sendAppendEntries(server, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">// the network or peer goes wrong</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----- section 3: handle reply------</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"><span class="comment">// handle reply</span></span><br></pre></td></tr></table></figure>
<p>如上面代码，将发送 RPC 请求分成三个部分：</p>
<ol>
<li>构造请求参数 AppendEntriesArgs</li>
<li>发送 RPC 请求</li>
<li>处理请求回复 AppendEntriesReply</li>
</ol>
<p>代码块 1 和 3 分别上锁，在真正发送 RPC 请求时释放锁，因为其耗时可能会非常长。RequestVote RPC 发送时也类似，这里不再赘述。</p>
<h2 id="命名技巧">命名技巧</h2>
<p>如果一个函数需要在持有锁时才能调用，最好要在命名中有所体现，而不能只写在注释里。如使用 Locked 后缀：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeFollowerLocked(term <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeCandidateLocked() </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeaderLocked(term <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<h2 id="漏锁检测">漏锁检测</h2>
<p>golang 还在语言层面提供了对<strong>数据竞态（</strong> data race ）进行检测的选项 <code>-race</code>，如 <code>go test -run 2B -race</code> 。该选项可以帮忙识别出共享变量漏在访问或者修改时漏加锁的情况。在出现数据竞态时，会报出出现竞态的相关 goroutine 的调用栈，包括创建线程、读取线程和修改线程，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at <span class="number">0x00c0004cb088</span> by goroutine <span class="number">1459</span>:</span><br><span class="line">  <span class="number">6.5840</span>/raft.(*Raft).becomeCandidateLocked()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/raft.<span class="keyword">go</span>:<span class="number">233</span> +<span class="number">0x27c</span></span><br><span class="line">  <span class="number">6.5840</span>/raft.(*Raft).electionTicker()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/raft_election.<span class="keyword">go</span>:<span class="number">180</span> +<span class="number">0x2c4</span></span><br><span class="line">  <span class="number">6.5840</span>/raft.Make.func1()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/raft.<span class="keyword">go</span>:<span class="number">356</span> +<span class="number">0x34</span></span><br><span class="line"></span><br><span class="line">Previous read at <span class="number">0x00c0004cb088</span> by goroutine <span class="number">1484</span>:</span><br><span class="line">  <span class="number">6.5840</span>/raft.(*Raft).replicateTicker()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/raft_replication.<span class="keyword">go</span>:<span class="number">209</span> +<span class="number">0xa0</span></span><br><span class="line">  <span class="number">6.5840</span>/raft.(*Raft).startElection.func1<span class="number">.2</span>()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/raft_election.<span class="keyword">go</span>:<span class="number">140</span> +<span class="number">0x40</span></span><br><span class="line"></span><br><span class="line">Goroutine <span class="number">1459</span> (running) created at:</span><br><span class="line">  <span class="number">6.5840</span>/raft.Make()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/raft.<span class="keyword">go</span>:<span class="number">356</span> +<span class="number">0x578</span></span><br><span class="line">  <span class="number">6.5840</span>/raft.(*config).start1()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/config.<span class="keyword">go</span>:<span class="number">322</span> +<span class="number">0x778</span></span><br><span class="line">  <span class="number">6.5840</span>/raft.make_config()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/config.<span class="keyword">go</span>:<span class="number">101</span> +<span class="number">0x76c</span></span><br><span class="line">  <span class="number">6.5840</span>/raft.TestFailNoAgree2B()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/test_test.<span class="keyword">go</span>:<span class="number">305</span> +<span class="number">0x3c</span></span><br><span class="line">  testing.tRunner()</span><br><span class="line">      /opt/homebrew/Cellar/<span class="keyword">go</span>/<span class="number">1.20</span><span class="number">.6</span>/libexec/src/testing/testing.<span class="keyword">go</span>:<span class="number">1576</span> +<span class="number">0x188</span></span><br><span class="line">  testing.(*T).Run.func1()</span><br><span class="line">      /opt/homebrew/Cellar/<span class="keyword">go</span>/<span class="number">1.20</span><span class="number">.6</span>/libexec/src/testing/testing.<span class="keyword">go</span>:<span class="number">1629</span> +<span class="number">0x40</span></span><br><span class="line"></span><br><span class="line">Goroutine <span class="number">1484</span> (finished) created at:</span><br><span class="line">  <span class="number">6.5840</span>/raft.(*Raft).startElection.func1()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/raft_election.<span class="keyword">go</span>:<span class="number">140</span> +<span class="number">0x3ec</span></span><br><span class="line">  <span class="number">6.5840</span>/raft.(*Raft).startElection.func3()</span><br><span class="line">      /Users/qtmuniao/code/<span class="number">6.5840</span>/src/raft/raft_election.<span class="keyword">go</span>:<span class="number">165</span> +<span class="number">0x54</span></span><br></pre></td></tr></table></figure>
<p>通过该选项检测，我发现我容易在几个地方漏加锁：</p>
<ol>
<li>访问共享变量的日志中</li>
<li>使用共享变量的判断条件里</li>
<li>只有一条返回共享变量语句的函数中</li>
</ol>
<h1>其他</h1>
<p>锁是最常用的多线程同步手段。在 raft 中，除了锁之外，还会涉及其他几种同步方法，包括 <code>channel</code> 和 <code>sync.Cond </code>。</p>
<h2 id="Channel">Channel</h2>
<p>channel 本质上是一个线程安全的消息队列，将 channel 作为语言内置类型来实现，是 golang 语言的一大特点。我们知道线程间通信有两大流派：<strong>共享内存</strong>（通过内存）和<strong>消息传递</strong>（通过消息队列）。golang 推荐第二个流派，原因是更安全，因此直接将 channel 作为内置类型。</p>
<p>但当然，我们的 raft 实现还是主要使用共享内存的方式来通信，因为更简单。本 raft 实验中用到 channel 的地方主要是 applyChannel，即当日志被大多数节点提交时，就通过 channel 传给 raft 使用方（后面的 KVStore）。使用方再决定如何对日志进行应用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, applyMsg := <span class="keyword">range</span> messages &#123;</span><br><span class="line">    rf.applyCh &lt;- *applyMsg <span class="comment">// maybe block, should release lock</span></span><br><span class="line"></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.lastApplied++</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sync-Cond">sync.Cond</h2>
<p>Golang 中 Sync.Cond 就是操作系统中信号量源语 —— wait signal 的一个实现。用于多线程间同步：比如某个线程 P1 做完了准备工作，通知另外的线程 P2 做正式处理。则 P2 必须等待 P1 完成再执行，而不能随意执行。此时，就可以使用 <code>sync.Cond </code>。</p>
<p>需要注意的是，<code>sync.Cond</code> 必须和 <code>sync.Mutex</code> 配合使用，即每个 <code>sync.Cond</code> 都要在构造的时候绑定一个 <code>sync.Mutex</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rf.applyCond = sync.NewCond(&amp;rf.mu)</span><br></pre></td></tr></table></figure>
<p>这是因为 <code>Wait()</code> 和 <code>Signal()</code> 函数必须<strong>在锁保护下的临界区中执行</strong>。其语义是：</p>
<ol>
<li><code>Wait() </code>会阻塞 goroutine 执行，并释放当前持有的锁。</li>
<li><code>Signal()</code> 会唤醒阻塞在 <code>Wait()</code> 上的 goroutine。</li>
</ol>
<p>由于阻塞在 <code>Wait()</code> 上的 goroutine 被唤醒后会<strong>自动</strong>重新获取锁，这就要求调用完 <code>Signal()</code> 的 goroutine 要立即释放锁，否则可能形成死锁。在 raft 中，主要用于在 rf.commitIndex 被更新后，提醒 apply goroutine 去执行 apply。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wait in apply loop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applyLoop() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.applyCond.Wait()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do the apply</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signal in the leader</span></span><br><span class="line"><span class="comment">// in AppendEntriesReply handling</span></span><br><span class="line"><span class="keyword">if</span> n &gt; rf.commitIndex &amp;&amp; rf.log[n].Term == rf.currentTerm &#123;</span><br><span class="line">    rf.commitIndex = n</span><br><span class="line">    rf.applyCond.Signal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singal in the follower</span></span><br><span class="line"><span class="comment">// in AppendEntries callback</span></span><br><span class="line"><span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">    targetIndex := MinInt(args.LeaderCommit, <span class="built_in">len</span>(rf.log)<span class="number">-1</span>)</span><br><span class="line">    rf.commitIndex = targetIndex</span><br><span class="line">    rf.applyCond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ol>
<li>The Go Memory Model：<a href="https://go.dev/ref/mem">https://go.dev/ref/mem</a></li>
<li>Raft Locking Advice：<a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt</a></li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
  <entry>
    <title>37 附录2. 分布式调试</title>
    <url>//23d7aeb6.html</url>
    <content><![CDATA[<p>在分布式系统中进行调试本就是一个难点，而本实验无疑让这一点更加困难：</p>
<ol>
<li><strong>多机日志混杂</strong>。用单机模拟的分布式系统，将所有节点的日志汇聚到了一块，无疑加大了根据日志进行问题定位的难度。</li>
<li><strong>网络环境复杂</strong>。为了在较短时间测出各种边角情况，本实验的测试通过（使用 labrpc 进行 mock）接管 RPC 层，将真实环境中<strong>频次很低</strong>的网络故障（RPC 消息<strong>乱序</strong>到达或者干脆<strong>丢失</strong>）大大提高。这让日志中的时间线非常难以追踪，进而定位各种事情发生的因果关系。</li>
</ol>
<p>实验所需的 Raft 的代码并不算太多，最终大家花在调试（Debug）的时间要远比编码的时间要多，当然在真实工作中也是如此。因此，一个科学的调试方法就显的非常重要，他能大大加快你定位问题的速度。甚而，一个好的调试方法能让枯燥的调试过程变成充满趣味性的通关过程。</p>
<p>下面主要参考 <a href="https://blog.josejg.com/debugging-pretty/">Debugging by Pretty Printing</a> 一文和我的一些经验，来介绍一种针对本实验多节点日志混杂、RPC 通信多变的情况的调试技术。</p>
<h1>基本原理</h1>
<p>对于编程调试，我们最常用的方法有两种：<strong>借助工具单步执行</strong>和<strong>手动埋点分析</strong>。但无论是多线程还是分布式编程，使用（类似的 gdb）工具进行单步调试都非常困难——程序的工作流太多了。此外，对于 Raft 这种逻辑正确严重依赖超时的代码来说，单步调试更加困难——会造成线程停顿，使得调试本身影响程序的正确性。</p>
<p>因此只剩下了手动埋点进行分析了，通俗来说，最常用的就是<strong>打日志</strong>。其他常见的埋点手段包括通过 http 等接口暴露一些运行时的各种信息，比如 <a href="https://prometheus.io/">Prometheus</a> 监控，这里就不再展开了。</p>
<p>如果做过数据可视化等相关工作，就会有一个感觉：多维的图形信息要比单一的文本流更加直观。因此我们的目标是：<strong>将一维的日志信息，尽可能地进行多维呈现</strong>。在<strong>命令行环境中</strong>（不然还得自己做图形界面，就太复杂了）我们可以利用的维度有：</p>
<ol>
<li>纵向</li>
<li>横向</li>
<li>颜色</li>
</ol>
<p>然后我们选取日志中我们最关心的三个因素，对齐到这三个维度即可：</p>
<ol>
<li>纵向：表时间先后，和普通日志一样，越到下面日志越新。</li>
<li>横向：表节点不同，每个节点一列。</li>
<li>颜色：表事件各异，每种事件一种颜色，如领导选举、日志同步、持久化等等。</li>
</ol>
<p><img src="./assets/s2-1.PNG" alt="s2-1"></p>
<h1>实现细节</h1>
<p>利用上述思想，使用日志手段进行调试实际上被分成了两个阶段：</p>
<ol>
<li>划分事件（event）模块，然后在合适的地方输出日志。</li>
<li>将代码运行中产生的一维日志处理成多维呈现。</li>
</ol>
<p>前者需要改造 lab 中的日志输出，后者需要编写一个小工具。</p>
<h2 id="输出日志">输出日志</h2>
<p>在输出日志时，通常会有几个需求：</p>
<ol>
<li>划分日志时间模块</li>
<li>控制日志输出详尽级别</li>
</ol>
<h3 id="模块划分">模块划分</h3>
<p>即对日志按事件种类划分模块。这件事没有一个固定标准，看每个人的偏好，且如果在调试时发现不直观及时调整即可，这里我给一个大致的方法。</p>
<p>从大类上来说，我们可以按级别将日志分为<strong>四大类</strong>：DEBUG, INFO，WARN，ERROR。重要程度依次递增：</p>
<ol>
<li>DEBUG：覆盖<strong>大部分事件</strong>的调试信息，任何可能会关心的数据结构变化和事件发生都可以输出。比如 rpc 发送前打印、收到后打印，数量比较大，可能会影响性能，一般我们不打开。</li>
<li>INFO：<strong>关键事件</strong>的信息，比如 term 变更、发起选举、更新 matchIndex、更新 commitIndex 等等。</li>
<li>WARN：<strong>异常行为</strong>的信息，但不影响程序的正确运行。比如，RPC 没有收到。</li>
<li>ERROR：影响程序<strong>正确运行</strong>的信息。比如发现某个 Term 选出了两个 Leader。</li>
</ol>
<p>然后为了方便调试，我们将 INFO 继续细分为几个重要模块：</p>
<ol>
<li>Vote：谁投票给谁，谁拒绝谁的投票</li>
<li>Log：发送日志方</li>
<li>Log2：接受日志方</li>
<li>Term：Term 发生变更</li>
<li>Persist：对 Raft 字段持久化</li>
<li>Drop：删除 Log 日志</li>
<li>Commit：提交日志</li>
</ol>
<p>等等，你可以根据自己偏好进行调整。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    DError logTopic = <span class="string">&quot;ERRO&quot;</span> <span class="comment">// level = 3</span></span><br><span class="line">    DWarn  logTopic = <span class="string">&quot;WARN&quot;</span> <span class="comment">// level = 2</span></span><br><span class="line">    DInfo  logTopic = <span class="string">&quot;INFO&quot;</span> <span class="comment">// level = 1</span></span><br><span class="line">    DDebug logTopic = <span class="string">&quot;DBUG&quot;</span> <span class="comment">// level = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// level = 1</span></span><br><span class="line">    DClient  logTopic = <span class="string">&quot;CLNT&quot;</span></span><br><span class="line">    DCommit  logTopic = <span class="string">&quot;CMIT&quot;</span></span><br><span class="line">    DDrop    logTopic = <span class="string">&quot;DROP&quot;</span></span><br><span class="line">    DLeader  logTopic = <span class="string">&quot;LEAD&quot;</span></span><br><span class="line">    DLog     logTopic = <span class="string">&quot;LOG1&quot;</span> <span class="comment">// sending log</span></span><br><span class="line">    DLog2    logTopic = <span class="string">&quot;LOG2&quot;</span> <span class="comment">// receiving log</span></span><br><span class="line">    DPersist logTopic = <span class="string">&quot;PERS&quot;</span></span><br><span class="line">    DSnap    logTopic = <span class="string">&quot;SNAP&quot;</span></span><br><span class="line">    DTerm    logTopic = <span class="string">&quot;TERM&quot;</span></span><br><span class="line">    DTest    logTopic = <span class="string">&quot;TEST&quot;</span></span><br><span class="line">    DTimer   logTopic = <span class="string">&quot;TIMR&quot;</span></span><br><span class="line">    DTrace   logTopic = <span class="string">&quot;TRCE&quot;</span></span><br><span class="line">    DVote    logTopic = <span class="string">&quot;VOTE&quot;</span></span><br><span class="line">    DApply   logTopic = <span class="string">&quot;APLY&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="级别控制">级别控制</h3>
<p>我们按上面提到的分类，将日志本身分为四个级别：Debug，Info，Warn 和 Error，按重要程度，日志级别依次递增。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTopicLevel</span><span class="params">(topic logTopic)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> topic &#123;</span><br><span class="line">    <span class="keyword">case</span> DError:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> DWarn:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> DInfo:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> DDebug:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓对日志级别进行控制，就是在程序执行前可以动态的设置日志级别，而在运行前将级别参数传入 Raft 进程，通常有<strong>命令行参数</strong>和<strong>环境参数</strong>两种。这里使用环境参数，简单一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEnvLevel</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    v := os.Getenv(<span class="string">&quot;VERBOSE&quot;</span>)</span><br><span class="line">    level := getTopicLevel(DError) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">        level, err = strconv.Atoi(v)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatalf(<span class="string">&quot;Invalid verbosity %v&quot;</span>, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set env when run test</span></span><br><span class="line"><span class="comment">// VERBOSE=1 go test -run 2A</span></span><br></pre></td></tr></table></figure>
<p>每条日志本身的级别我们称为 <code>topicLevel</code>，进行控制的传入级别我们称为 <code>logLevel</code>。我们将 <code>logLevel</code> 作为一个<strong>低水位线</strong>，输出所有高于此 <code>logLevel</code> 的日志。当然，也可以将 <code>logLevel</code> 作为高水位线，这取决于你的习惯。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">topicLevel := getTopicLevel(topic)</span><br><span class="line"><span class="keyword">if</span> logLevel &lt;= topicLevel &#123;</span><br><span class="line">    <span class="comment">// print the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="格式细节">格式细节</h2>
<p>首先要在日志前缀输出我们在多维呈现的地方提到的几个关心的维度（时间、空间、模块）：time、term、peerId、和 topic，用空格分开，并保证对齐，方便后续对日志进行升维处理。这些维度数据本质上是这条日志的<strong>元信息</strong>，或者叫<strong>日志头</strong>。</p>
<p>当然，三个维度中我们没有提到 term，但我在跟踪日志的时候发现他也是一个非常重要的信息，所以就放在元信息里了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LOG</span><span class="params">(peerId <span class="type">int</span>, term <span class="type">int</span>, topic logTopic, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    topicLevel := getTopicLevel(topic)</span><br><span class="line">    <span class="keyword">if</span> logLevel &lt;= topicLevel &#123;</span><br><span class="line">        time := time.Since(logStart).Microseconds()</span><br><span class="line">        time /= <span class="number">100</span></span><br><span class="line">        prefix := fmt.Sprintf(<span class="string">&quot;%06d T%04d %v S%d &quot;</span>, time, term, <span class="type">string</span>(topic), peerId)</span><br><span class="line">        format = prefix + format</span><br><span class="line">        log.Printf(format, a...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要解释下，Golang 自带的日志 time 格式太长了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, time.Now())</span><br><span class="line"><span class="comment">// 2023-08-18 09:55:31.930155 +0800 CST m=+1.118178251</span></span><br></pre></td></tr></table></figure>
<p>但其实在 Raft 中我们并不关心这么多信息，我们只关心单次测试的时间线。因此借鉴 Unix 时间戳的思想，将程序运行时 <code>logStart</code> 作为计时起点，然后输出打印日志时间点和起始时间点 <code>logStart</code>的差值 <code>time.Since(logStart).Microseconds()</code> 即可。当然，由于我们使用 log 进行日志输出，需要通过设置标记位把默认的 date 和 time 信息关掉。这里的输出精度是 10 us，你可以按自己喜好进行调整。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logLevel = getEnvLevel()</span><br><span class="line">    logStart = time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not print verbose date</span></span><br><span class="line">    log.SetFlags(log.Flags() &amp;^ (log.Ldate | log.Ltime))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在元信息之外，每一条日志具体要输出什么样的内容呢？</p>
<p>每个人都有自己的偏好，这里提一条原则：在日志中输出<strong>尽可能多</strong>，但<strong>尽可能简洁</strong>的信息。尽可能多的信息好理解，毕竟信息多了才方便追踪因果逻辑。但为什么要尽可能简洁呢？因为 Raft 运行时会输出非常多的日志，如果不保持每条日志的简洁，我们很容易被日志洪流所淹没。</p>
<p>下面是我总结的保持日志简洁的一些小技巧：</p>
<ol>
<li><strong>保持格式大体一致</strong>。
<ol>
<li>结构一致：日志头、日志主语、事件描述、数据结构输出</li>
<li>格式一致：首字母大小写、Term 带前缀 T、 Server 带前缀 S、Term 和 Index 同时出现 Index 用中括号括起来等等。</li>
</ol>
</li>
<li><strong>描述只保留关键字</strong>。所有不必要谓词、介词、修饰语等等没有信息含量的单词都去掉。</li>
<li><strong>合理使用箭头符号</strong>。使用箭头符号来简洁的表示 <code>RequestVote</code> 和 <code>AppendEntries</code> 等事件控制流向，总是
<ol>
<li>Candidate -&gt; Other Peer</li>
<li>Leader -&gt; Other Peer</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">003075</span> T0002 PERS S2 Persist Term:<span class="number">2</span>, Vote:<span class="number">2</span>, Logs:<span class="number">2</span></span><br><span class="line"><span class="number">004078</span> T0002 LOG2 S0 &lt;- S2, Receive, prev=[<span class="number">0</span>]T0 at T2</span><br><span class="line"><span class="number">004079</span> T0002 PERS S0 Persist Term:<span class="number">2</span>, Vote:<span class="number">2</span>, Logs:<span class="number">2</span></span><br><span class="line"><span class="number">004079</span> T0002 LOG2 S0 &lt;- S2, Accept log, (<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">004079</span> T0002 TIMR S0 Accept log, reset timer</span><br><span class="line"><span class="number">004078</span> T0002 LOG2 S1 &lt;- S2, Receive, prev=[<span class="number">0</span>]T0 at T2</span><br><span class="line"><span class="number">004079</span> T0002 PERS S1 Persist Term:<span class="number">2</span>, Vote:<span class="number">2</span>, Logs:<span class="number">2</span></span><br><span class="line"><span class="number">004079</span> T0002 LOG2 S1 &lt;- S2, Accept log, (<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">004079</span> T0002 TIMR S1 Accept log, reset timer</span><br><span class="line"><span class="number">004079</span> T0002 LOG1 S2 -&gt; S0, Accept, update matchIndex=[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">004079</span> T0002 LOG1 S2 Update commitIndex: <span class="number">0</span>-&gt;<span class="number">1</span> actively</span><br><span class="line"><span class="number">004079</span> T0002 APLY S2 Apply log as Leader, idx=[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">004079</span> T0002 LOG1 S2 -&gt; S1, Accept, update matchIndex=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">005289</span> T0002 LOG2 S0 &lt;- S2, Receive, prev=[<span class="number">1</span>]T2 at T2</span><br><span class="line"><span class="number">005290</span> T0002 PERS S0 Persist Term:<span class="number">2</span>, Vote:<span class="number">2</span>, Logs:<span class="number">2</span></span><br><span class="line"><span class="number">005290</span> T0002 LOG2 S0 &lt;- S2, Accept log, (<span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>上述日志是我随意截取的一段日志，加黑部分是日志头，可以看出对于变长字段（比如 Time、Term）都用 0 进行补齐了。</p>
<p>S0 代表 Server-0，也可以根据你的喜好称为 P0，Peer0。比较取巧（ tricky ）的一点是，我们把主语部分放到了日志头最后，这样就可以拼接后面的箭头和谓语头（下面高亮部分）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">004079</span> T0002 LOG1 S2 -&gt; S1, Accept, update matchIndex=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1>升维工具</h1>
<p>虽然使用 shell 脚本也可以对生成的日志进行处理，但是相比 shell ，Python 的语法和生态无疑要强大的多。这里主要采用<a href="https://gist.github.com/JJGO/e64c0e8aedb5d464b5f79d3b12197338">该脚本</a>。基本思想是：</p>
<ol>
<li>提取日志头中的元信息</li>
<li>将不同 Server 的日志打印到不同列（借助 <a href="https://github.com/Textualize/rich">rich</a> 库）</li>
<li>做颜色映射表，将不同 Topic 的日志用不同颜色进行打印（借助 <a href="https://github.com/Textualize/rich">rich</a> 库）</li>
<li>提供一些简单的命令行参数指定 Server 数量、按 Topic 过滤、控制日志级别等等（借助 <a href="https://github.com/tiangolo/typer">typer</a> 库）。</li>
</ol>
<p>使用命令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">VERBOSE=<span class="number">1</span> <span class="keyword">go</span> test -run TestBasicAgree2B | dslogs -c <span class="number">3</span> -i PERS</span><br></pre></td></tr></table></figure>
<p><code>-c 3</code> 表示有个三个 server，<code>-i PERS</code> 表示过滤（ignore）掉 Persist 的输出。</p>
<p><img src="./assets/s2-2.png" alt="s2-2"></p>
<p>我们可以根据我们的需要，对脚本做一些定制。比如我在日志头里新增了 Term，就要加入相应的解析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">time, term, topic, *msg = line.strip().split(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<p>对于有些测试，比如 <code>TestFigure8Unreliable2C</code> ，需要高并发、运行很多遍才有可能触发失败，而我们只关心失败时候的日志，因此还需要一个小工具来做这件事情：</p>
<ol>
<li><strong>指定运行并发数</strong>。提高并发有两个好处，一来加速测试效率，二来提高出错可能。</li>
<li><strong>多次运行，记录出错时日志</strong>。正确跑完的日志我们是不关心的。</li>
</ol>
<p>这里采用与上述同一助教的该<a href="https://gist.github.com/JJGO/0d73540ef7cc2f066cb535156b7cbdab">脚本</a>。虽然也可以用 Shell，但用 Python 可以做出更友好的界面和控制流程。比如，我们用 30 个并发将 lab 2C 跑一百次：</p>
<p><img src="./assets/s2-3.png" alt="s2-3"></p>
<h1>分析思路</h1>
<p>在实际对出错日志进行分析的时候，我们可以使用一些技巧：</p>
<ol>
<li>确定某个 Term 是谁先开启的</li>
<li>注意某些 RPC 是否乱序到达了</li>
<li>确定某个 server 有问题时，可以通过 <code>grep S1 output.log | dslog -c 5</code> 等方式，专门过滤出和该 server 相关的所有日志。</li>
</ol>
<h1>参考</h1>
<ol>
<li>Debugging by Pretty Printing：<a href="https://blog.josejg.com/debugging-pretty/">https://blog.josejg.com/debugging-pretty/</a></li>
</ol>
]]></content>
      <tags>
        <tag>分布式KV</tag>
      </tags>
  </entry>
</search>
